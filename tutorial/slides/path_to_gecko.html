<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Felix Klock (pnkfelix) and the Rust Team" />
  <title>A Rusty Path to Gecko</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.css"/>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #dddddd; }
td.sourceCode { padding-left: 5px; }
code > span.kw { font-weight: bold; } /* Keyword */
code > span.dt { color: #800000; } /* DataType */
code > span.dv { color: #0000ff; } /* DecVal */
code > span.bn { color: #0000ff; } /* BaseN */
code > span.fl { color: #800080; } /* Float */
code > span.ch { color: #ff00ff; } /* Char */
code > span.st { color: #dd0000; } /* String */
code > span.co { color: #808080; font-style: italic; } /* Comment */
code > span.al { color: #00ff00; font-weight: bold; } /* Alert */
code > span.fu { color: #000080; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #ff0000; font-weight: bold; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #ff00ff; } /* SpecialChar */
code > span.vs { color: #dd0000; } /* VerbatimString */
code > span.ss { color: #dd0000; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { } /* ControlFlow */
code > span.op { } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { font-weight: bold; } /* Preprocessor */
code > span.at { } /* Attribute */
code > span.do { color: #808080; font-style: italic; } /* Documentation */
code > span.an { color: #808080; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #808080; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #808080; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
  <link rel="stylesheet" href="../../slide-style.css"/>
  <!-- If the query includes 'print-pdf', include the PDF print sheet -->
  <script>
    if( window.location.search.match( /print-pdf/gi ) ) {
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = 'reveal.js/css/print/pdf.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">A Rusty Path to Gecko</h1>
    <h2 class="author">Felix Klock (<code>pnkfelix</code>) and the Rust Team</h2>
    <h3 class="date">Thursday 25 June</h3>
</section>

<section><section id="rust-how-do-we-get-to-gecko" class="titleslide slide level1"><h1>Rust: How do we get to Gecko?</h1></section><section id="goals-for-today" class="slide level2">
<h1>Goals for today</h1>
<ul>
<li>Convince you Rust is awesome</li>
<li>Provide seeds of knowledge
<ul>
<li>One can only cultivate so much during a three hour window</li>
</ul></li>
</ul>
</section><section id="goals-for-rust" class="slide level2">
<h1>Goals for Rust</h1>
<ul>
<li><p>Safe. Concurrent. Fast.</p></li>
<li>Specifics
<ul>
<li>Memory safety without garbage collection</li>
<li>Concurrency without data races</li>
<li>Abstraction without overhead</li>
</ul></li>
<li><p>Generalization: HACK WITHOUT FEAR!</p></li>
</ul>
</section><section id="let-us-see-some-code" class="slide level2">
<h1>Let us see some code</h1>
<ul>
<li>These are <em>&quot;amuse bouches&quot;</em>
<ul>
<li>not the main course</li>
<li>(not even an appetizer)</li>
</ul></li>
<li>Do not worry if it goes too fast</li>
</ul>
</section><section id="high-level-but-fast" class="slide level2">
<h1>High-level, but fast</h1>
<p>The below <a href="https://play.rust-lang.org/?gist=23a69161dd4421e2925f">loop demo</a> compiles down to tight code:</p>
<!--
```rust
#[allow(dead_code)]
fn main() {
    let v1: Vec<i32> = (-100..10).collect();
    let s1 = sum_pos(&v1);
    let v2: Vec<i32> = (-100..1000).collect();
    let s2 = sum_pos(&v2);
    println!("v1.len: {} s1: {} v2.len: {} s2: {}", v1.len(), s1, v2.len(), s2);
}

#[allow(dead_code)]
#[inline(never)]
```
-->
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// sums all the positive values in `v`</span>
<span class="kw">fn</span> sum_pos(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; <span class="dt">i32</span> {
    <span class="kw">let</span> <span class="kw">mut</span> sum = <span class="dv">0</span>;
    <span class="kw">for</span> i <span class="kw">in</span> v.iter().filter(|i| **i &gt; <span class="dv">0</span>) {
        sum += *i;
    }
    sum
}</code></pre></div>
</section><section class="slide level2">

<p>Generated x86_64 machine code for <code class="sourceCode rust"><span class="kw">fn</span> sum_pos</code>:</p>
<div class="sourceCode"><pre class="sourceCode nasm"><code class="sourceCode nasm">    leaq    (<span class="ot">%rdi,%rsi,4), %rcx</span>
    xorl    <span class="ot">%eax, %eax</span>
    <span class="kw">jmp</span> .LBB5_1
<span class="fu">.LBB5_3:</span>
    addl    <span class="ot">%edx, %eax</span>
    .<span class="kw">align</span>  <span class="dv">16</span><span class="bn">, 0x90</span>
<span class="fu">.LBB5_1:</span>
    cmpq    <span class="ot">%rdi, %rcx</span>
    <span class="kw">je</span>  .LBB5_4
    movl    (<span class="ot">%rdi), %edx</span>
    addq<span class="bn">    $4, </span><span class="ot">%rdi</span>
    testl   <span class="ot">%edx, %edx</span>
    <span class="kw">jle</span> .LBB5_1
    <span class="kw">jmp</span> .LBB5_3
<span class="fu">.LBB5_4:</span>
    retq</code></pre></div>
<p>(when compiled in &quot;release mode&quot;)</p>
</section><section id="memory-safety" class="slide level2">
<h1>Memory safety</h1>
<p>Example: catches iterator invalidation bugs</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> this_wont_compile(v: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; <span class="dt">i32</span> {
    <span class="kw">let</span> <span class="kw">mut</span> sum = <span class="dv">0</span>;
    <span class="kw">for</span> &amp;i <span class="kw">in</span> v.iter() {
        <span class="kw">if</span> i &gt; <span class="dv">0</span> { v.push(<span class="dv">0</span>); } sum += i;
    }
    sum
}</code></pre></div>
<pre class="fragment"><code>error: cannot borrow `*v` as mutable because it is also borrowed
       as immutable
        if i &gt; 0 { v.push(0); } sum += i;
                   ^
note: previous borrow of `*v` occurs here; the immutable borrow
      prevents subsequent moves or mutable borrows of `*v` until
      the borrow ends
    for &amp;i in v.iter() {
              ^</code></pre>
</section><section id="concurrency" class="slide level2">
<h1>Concurrency</h1>
<p>See also <a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Fearless Concurrency</a> blog post.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
<span class="kw">fn</span> par_merge_sort&lt;T: <span class="bu">Ord</span> + <span class="bu">Send</span>&gt;(x: &amp;<span class="kw">mut</span> [T]) {
    <span class="kw">if</span> x.len() &lt;= <span class="dv">1</span> { <span class="kw">return</span> }
    <span class="kw">let</span> half = x.len() / <span class="dv">2</span>;
    <span class="kw">let</span> (l, r) = x.split_at_mut(half);
    <span class="kw">let</span> g = thread::scoped(|| { par_merge_sort(r);
                                r });
    par_merge_sort(l);
    <span class="kw">let</span> r = g.join();
    merge(l, r);
}</code></pre></div>
<p>(caveat: above is using unstable <code>thread::scoped</code> API)</p>
<!--
```rust
// left[0] <= left[1] <= ... <= left[last] <= right[0] <= ...
use std::mem;
#[allow(dead_code)]
fn merge<T: Ord>(left: &mut [T], right: &mut [T]) {

    let mut i = 0;
    loop {
        // println!("i: {} left: {:?} right: {:?}", i, left, right);
        if i >= left.len() || 0 >= right.len() { break; }
        if left[i] > right[0] {
            mem::swap(&mut left[i], &mut right[0]);
            let mut j = 0;
            while j+1 < right.len() && right[j] > right[j+1] {
                let (pre, post) = right.split_at_mut(j+1);
                mem::swap(&mut pre[j], &mut post[0]);
                j = j+1;
            }
        }
        i += 1;
    }
}

#[test]
fn hi() {
    let mut v = vec![2, 1, 10, 9, 8, 7, 6, 5, 4, 3];
    par_merge_sort(&mut v);
    assert_eq!(v, [1,2,3,4,5,6,7,8,9,10]);
}
```
-->
</section></section>
<section><section id="lets-dive-in" class="titleslide slide level1"><h1>Lets dive in</h1></section><section id="outline-for-tutorial" class="slide level2">
<h1>Outline for Tutorial</h1>
<ul>
<li>Goals</li>
<li>Ownership and Borrowing; Arrays and Strings</li>
<li>Local Development: Cargo; Crates and Modules</li>
<li>More Fundamentals: Data; More on Borrowing; Traits</li>
<li>Systems Development: Concurrency and I/O; FFI</li>
</ul>
</section></section>
<section><section id="part-1-playpen" class="titleslide slide level1"><h1>Part 1: Playpen</h1></section><section id="playpen" class="slide level2">
<h1>Playpen</h1>
<ul>
<li>For now, open <a href="http://play.rust-lang.org/"><code>http://play.rust-lang.org/</code></a> in a web browser.</li>
</ul>
<ul>
<li>For later: Install Rust from the USB stick when it comes to you</li>
</ul>
<!--
## Test slide

```rust
// 01

//000000011111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890
// 05




// 10


// 13
// 14
// 15
// 16
// 17
// 18
// 19
// 20
// 21
// 22
// 23
// 24
// 25
```
-->
</section><section id="rust-basics" class="slide level2">
<h1>Rust Basics</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> main() {
    <span class="pp">println!</span>(<span class="st">&quot;Hello World!&quot;</span>); <span class="co">// (`!` means macro)</span>
    print_ten();                                               
}

<span class="kw">fn</span> print_ten() {
    <span class="pp">println!</span>(<span class="st">&quot;Ten: {}&quot;</span>, <span class="dv">10</span>);
    <span class="co">//             ~~   ~~</span>
    <span class="co">//             |     | </span>
    <span class="co">//    placeholder   argument</span>
}</code></pre></div>
</section><section id="usual-stuff" class="slide level2">
<h1>Usual stuff</h1>
<ul>
<li>Local variables: <code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">3</span>;</code>
<ul>
<li>Optional type annotations: <code class="sourceCode rust"><span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">3</span>;</code></li>
</ul></li>
<li><p>If expressions: <code class="sourceCode rust"><span class="kw">if</span> test { then(); also() } <span class="kw">else</span> { other() }</code></p></li>
<li>Loops: <code class="sourceCode rust"><span class="kw">while</span> test { first(); second(); ... }</code>
<ul>
<li>Also <code class="sourceCode rust"><span class="kw">for</span> i <span class="kw">in</span> iterator { f(); g(); ... }</code></li>
</ul></li>
<li><p>Standalone functions:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add8(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> {
    <span class="pp">println!</span>(<span class="st">&quot;add8&quot;</span>);
    <span class="kw">return</span> x + <span class="dv">8</span>;
}</code></pre></div></li>
</ul>
</section><section id="unusual-stuff-1" class="slide level2">
<h1>Unusual stuff 1</h1>
<ul>
<li>Blocks have optional tail expressions</li>
<li>Tuples, Pattern binding</li>
<li>Algebraic Data, Pattern matching</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add8(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> { <span class="kw">return</span> x + <span class="dv">8</span>; }
<span class="kw">fn</span> add8(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> { x + <span class="dv">8</span> }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (x, y): (<span class="dt">i32</span>, <span class="dt">i32</span>) = int_pair;
(x + <span class="dv">8</span>, y + <span class="dv">8</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="kw">match</span> number_result {
    <span class="cn">Ok</span>(x)  =&gt; x + <span class="dv">8</span>,
    <span class="cn">Err</span>(e) =&gt; { <span class="pp">println!</span>(<span class="st">&quot;error: {}&quot;</span>, e); <span class="kw">break</span>; }
};</code></pre></div>
</section><section id="unusual-stuff-2" class="slide level2">
<h1>Unusual stuff 2</h1>
<ul>
<li>Generics, Trait Bounds</li>
<li>Objects via Traits</li>
<li>Ownership and Borrowing</li>
</ul>
<p>We start with <em>Ownership and Borrowing</em>; a critical concept for understanding Rust.</p>
</section><section id="language-and-api-docs" class="slide level2">
<h1>Language and API docs</h1>
<ul>
<li><p>All linked from top of <a href="http://www.rust-lang.org/" class="uri">http://www.rust-lang.org/</a></p></li>
<li>Starting points
<ul>
<li>The Book: <a href="https://doc.rust-lang.org/stable/book/" class="uri">https://doc.rust-lang.org/stable/book/</a></li>
<li>Standard API: <a href="https://doc.rust-lang.org/stable/std/]">https://doc.rust-lang.org/stable/std/</a></li>
</ul></li>
</ul>
</section></section>
<section><section id="ownership-and-move-semantics" class="titleslide slide level1"><h1>Ownership and Move Semantics</h1></section><section id="owned-vs-copied" class="slide level2">
<h1>Owned vs Copied</h1>
<ul>
<li><p>Consider assignment</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">left_side = right_side;</code></pre></div></li>
<li>Owned data
<ul>
<li><em>moves</em> <code>right_side</code> into <code>left_side</code></li>
<li><code>right_side</code> becomes inaccessible</li>
<li>one can still opt into explicit duplication, e.g. '<code class="sourceCode rust">new = owned.clone();</code>'</li>
</ul></li>
<li>Copied data
<ul>
<li><em>memcpy's</em> <code>right_side</code> into <code>left_side</code></li>
<li>one can freely keep using the original</li>
</ul></li>
</ul>
</section><section id="creating-an-owned-value" class="slide level2">
<h1>Creating an owned value</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> main() {
    <span class="kw">let</span> <span class="kw">mut</span> vec = <span class="dt">Vec</span>::new();
    vec.push(<span class="dv">2000</span>);
    vec.push( <span class="dv">400</span>);
    vec.push(  <span class="dv">60</span>);
    <span class="pp">println!</span>(<span class="st">&quot;vec: {:?}&quot;</span>, vec);
    <span class="kw">let</span> the_sum = sum(vec);
    <span class="pp">println!</span>(<span class="st">&quot;the_sum: {}&quot;</span>, the_sum);
}</code></pre></div>
</section><section id="consuming-an-owned-value" class="slide level2">
<h1>Consuming an owned value</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> sum(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; <span class="dt">i32</span> {
   <span class="kw">let</span> <span class="kw">mut</span> accum = <span class="dv">0</span>;
   <span class="kw">for</span> i <span class="kw">in</span> v { accum += i; }
   accum
}</code></pre></div>
</section><section id="borrowing-immutably-scopes-no-explicit-lifetimes" class="slide level2">
<h1>Borrowing (immutably), Scopes (no explicit lifetimes)</h1>
</section><section id="exclusive-access-versus-ownership-mut-borrows" class="slide level2">
<h1>Exclusive Access versus Ownership; &amp;mut borrows</h1>
</section><section id="vectors-and-arrays-and-slices" class="slide level2">
<h1>Vectors and Arrays and Slices</h1>
</section><section id="for-and-iterators-string-and-str" class="slide level2">
<h1>for and iterators; String and &amp;str</h1>
</section></section>
<section><section id="part-2-programming-in-the-large" class="titleslide slide level1"><h1>Part 2: Programming in the Large</h1></section><section id="everyones-installed-right" class="slide level2">
<h1>Everyone's installed (right?)</h1>
<p>What is local development like?</p>
<ul>
<li><p>rustc</p></li>
<li><p>cargo</p></li>
<li><p>modules and the filesystem</p></li>
<li><p>crates.io</p></li>
</ul>
</section><section id="rustc" class="slide level2">
<h1>rustc</h1>
<pre class="sh-session"><code>[bash]$ cat /tmp/hello.rs</code></pre>
<p><code class="filename">/tmp/hello.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() { <span class="pp">println!</span>(<span class="st">&quot;hello world&quot;</span>); }</code></pre></div>
<pre class="sh-session"><code>[bash]$ rustc /tmp/hello.rs -o /tmp/hello
[bash]$ /tmp/hello
hello world
[bash]$</code></pre>
</section><section id="getting-started-with-cargo" class="slide level2">
<h1>Getting started with cargo</h1>
<pre class="sh-session"><code>[bash]$ cargo new my-new-crate
[bash]$ cd my-new-crate
[bash]$ find * -type f
Cargo.toml
src/lib.rs
[bash]$ cat src/lib.rs</code></pre>
<p><code class="filename">src/lib.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> it_works() {
}</code></pre></div>
<pre class="sh-session"><code>[bash]$ cargo build
   Compiling my-new-crate v0.1.0 (file:///private/tmp/my-new-crate)
[bash]$ </code></pre>
</section><section class="slide level2">

<pre class="sh-session"><code>[bash]$ cargo test
   Compiling my-new-crate v0.1.0 (file:///private/tmp/my-new-crate)
     Running target/debug/my_new_crate-7ad82271427661a1

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests my-new-crate

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured

[bash]$ </code></pre>
</section><section class="slide level2">

<pre class="sh-session"><code>[bash]$ cd ..
[bash]$ cargo new --bin my-rust-program
[bash]$ cd my-rust-program
[bash]$ find * -type f
Cargo.toml
src/main.rs
[bash]$ cat src/main.rs</code></pre>
<p><code class="filename">src/main.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>);
}</code></pre></div>
<pre class="sh-session"><code>[bash]$ cargo run
   Compiling my-rust-program v0.1.0 (file:///private/tmp/my-rust-program)
     Running `target/debug/my-rust-program`
Hello, world!
[bash]$ </code></pre>
</section><section id="crates-versus-modules" class="slide level2">
<h1>crates versus modules</h1>
<ul>
<li><p>Crate: A unit of compilation</p></li>
<li><p>Module: A collection of items</p></li>
</ul>
</section><section id="crates" class="slide level2">
<h1>crates</h1>
<ul>
<li>A crate is a unit of compilation</li>
<li>Code can link to other previously compiled crates</li>
<li><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> other_crate;</code></li>
<li>compiler finds it in file system, extracts names and types of its exports</li>
<li>Makes <code>other_crate</code> available as a name to reference</li>
</ul>
</section><section id="modules" class="slide level2">
<h1>modules</h1>
<ul>
<li>Module is a collection of items</li>
<li>Purpose: namespacing and encapsulation</li>
<li>Note: a submodule is a kind of item.
<ul>
<li>i.e. modules form a hierarchy</li>
</ul></li>
<li>Modules can have cyclic references, <em>within</em> a single crate</li>
</ul>
</section><section id="module-hierarchy-and-file-system" class="slide level2">
<h1>module hierarchy and file system</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> a {
    <span class="kw">mod</span> b { <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>; }
    <span class="kw">mod</span> c {
        <span class="kw">use</span> <span class="kw">super</span>::b::I;
        <span class="kw">pub</span> <span class="kw">fn</span> add3(x: I) -&gt; I { x + <span class="dv">3</span> }
    }
}</code></pre></div>
<p>Or '<code class="sourceCode rust"><span class="kw">mod</span> name;</code>' with subfiles at proper paths</p>
<p><code class="filename">src/lib.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> a {
    <span class="kw">mod</span> b { <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>; }
    <span class="kw">mod</span> c;
}</code></pre></div>
<p><code class="filename">src/a/c.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">        <span class="kw">use</span> <span class="kw">super</span>::b::I;
        <span class="kw">pub</span> <span class="kw">fn</span> add3(x: I) -&gt; I { x + <span class="dv">3</span> }</code></pre></div>
</section><section id="using-pub-items" class="slide level2">
<h1>using pub items</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> d {
    <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>;
    <span class="kw">pub</span> <span class="kw">fn</span> add3(x: I) -&gt; I { add3priv(x) }
    <span class="kw">fn</span> add3priv(x: I) -&gt; I { x + <span class="dv">3</span> }
}

<span class="kw">mod</span> e {
    <span class="kw">use</span> <span class="kw">super</span>::d::add3;
    <span class="at">#[</span>test<span class="at">]</span> <span class="kw">fn</span> t() { <span class="pp">assert_eq!</span>(add3(<span class="dv">1</span>), <span class="dv">4</span>); }
}</code></pre></div>
</section><section id="privacy" class="slide level2">
<h1>privacy</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> d {
    <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>;
    <span class="kw">pub</span> <span class="kw">fn</span> add3(x: I) -&gt; I { add3priv(x) }
    <span class="kw">fn</span> add3priv(x: I) -&gt; I { x + <span class="dv">3</span> }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> f {
    <span class="kw">use</span> <span class="kw">super</span>::d::add3priv;
    <span class="at">#[</span>test<span class="at">]</span> <span class="kw">fn</span> t() { <span class="pp">assert_eq!</span>(add3priv(<span class="dv">1</span>), <span class="dv">4</span>); }
}</code></pre></div>
<pre class="shell-session"><code>error: function `add3priv` is private
    use super::d::add3priv;
        ^~~~~~~~~~~~~~~~~~</code></pre>
</section><section id="crates.io" class="slide level2">
<h1>crates.io</h1>
<p>Cargo's main feature: dependency management</p>
<p>FIXME do not jump straight into diamond problem</p>
</section><section id="diamonds" class="slide level2">
<h1>Diamonds</h1>
<p><code class="filename">add3/src/lib.rs (v1.0.0)</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> add3(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> { x + <span class="dv">3</span> }</code></pre></div>
<p><code class="filename">add3/src/lib.rs (v2.0.0)</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> add3(x: <span class="dt">i64</span>) -&gt; <span class="dt">i64</span> { x + <span class="dv">3</span> }</code></pre></div>
<p><code class="filename">add6/Cargo.toml</code></p>
<div class="sourceCode"><pre class="sourceCode ini"><code class="sourceCode ini"><span class="kw">[dependencies]</span>
<span class="dt">add3 </span><span class="ot">=</span><span class="st"> &quot;</span><span class="fl">1.0.0</span><span class="st">&quot;</span></code></pre></div>
<p><code class="filename">add6_64/Cargo.toml</code></p>
<div class="sourceCode"><pre class="sourceCode ini"><code class="sourceCode ini"><span class="kw">[dependencies]</span>
<span class="dt">add3 </span><span class="ot">=</span><span class="st"> &quot;</span><span class="fl">2.0.0</span><span class="st">&quot;</span></code></pre></div>
<p><code class="filename">diamond/Cargo.toml</code></p>
<div class="sourceCode"><pre class="sourceCode ini"><code class="sourceCode ini"><span class="kw">[dependencies.add6_64]</span>
<span class="dt">path </span><span class="ot">=</span><span class="st"> &quot;/Users/fklock/Dev/Rust/add6_64/&quot;</span>

<span class="kw">[dependencies.add6]</span>
<span class="dt">path </span><span class="ot">=</span><span class="st"> &quot;/Users/fklock/Dev/Rust/add6/&quot;</span></code></pre></div>
</section></section>
<section><section id="part-3-back-to-language-fundamentals" class="titleslide slide level1"><h1>Part 3: Back to Language Fundamentals</h1></section><section id="structs" class="slide level2">
<h1>structs</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Copy</span><span class="at">,</span> <span class="bu">Clone</span><span class="at">)]</span>
<span class="kw">struct</span> Point { <span class="kw">pub</span> x: <span class="dt">i32</span>, <span class="kw">pub</span> y: <span class="dt">i32</span> }

<span class="kw">fn</span> proj_x_axis(p: &amp;Point) -&gt; Point {
    Point { x: p.x, y: <span class="dv">0</span> } }

<span class="kw">fn</span> nudge_left(p: &amp;<span class="kw">mut</span> Point) { p.x -= <span class="dv">10</span>; }

<span class="at">#[</span>derive<span class="at">(</span><span class="bu">Copy</span><span class="at">,</span> <span class="bu">Clone</span><span class="at">)]</span>
<span class="kw">struct</span> Angle(<span class="kw">pub</span> <span class="dt">f64</span>);

<span class="kw">struct</span> Pair&lt;X,Y&gt;(X, Y);</code></pre></div>
</section><section class="slide level2">

<ul>
<li>FIXME does this slide actually pay for itself?
<ul>
<li>(<code>impl</code> alone?)</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> proj_x_axis(p: &amp;Point) -&gt; Point {
    Point { x: p.x, y: <span class="dv">0</span> }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> proj_x_axis(p: &amp;Point) -&gt; Point {
    Point { y: <span class="dv">0</span>, ..p }
}</code></pre></div>
<!--
```{.rust}
fn proj_x_axis_check(p: &Point) -> Point {
    Point { y: 0, ..p }
}
```
-->
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Point {
    <span class="kw">fn</span> proj_x_axis(&amp;<span class="kw">self</span>) -&gt; Point {
        Point { x: <span class="kw">self</span>.x, y: <span class="dv">0</span> }
    }
}</code></pre></div>
</section><section id="enums" class="slide level2">
<h1>enums</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Line {
    Segment { start: Point, end: Point },
    Vector(Point, Angle),
}

<span class="kw">fn</span> start(l: &amp;Line) -&gt; Point {
    <span class="kw">match</span> *l {
        Line::Vector(s, _) =&gt; s,
        Line::Segment { start: s, .. } =&gt; s,
    }
}</code></pre></div>
</section><section id="option-and-result" class="slide level2">
<h1>Option and Result</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Option</span>&lt;T&gt; { <span class="cn">Some</span>(T), <span class="cn">None</span> }

<span class="kw">enum</span> <span class="dt">Result</span>&lt;T, E&gt; { <span class="cn">Ok</span>(T), <span class="cn">Err</span>(E) }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::num::ParseIntError;
<span class="kw">fn</span> read_u32(s: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Result</span>&lt;<span class="dt">u32</span>, ParseIntError&gt; {
    s.parse()
}
<span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo() {
    <span class="pp">assert_eq!</span>(read_u32(<span class="st">&quot;4&quot;</span>), <span class="cn">Ok</span>(<span class="dv">4</span>));
    <span class="pp">assert!</span>(read_u32(<span class="st">&quot;4_no_no&quot;</span>).is_err());

    <span class="pp">assert_eq!</span>(read_u32(<span class="st">&quot;4&quot;</span>).ok(), <span class="cn">Some</span>(<span class="dv">4</span>));
}</code></pre></div>
</section><section id="scopes-and-lifetimes." class="slide level2">
<h1>Scopes and Lifetimes.</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> show_some_lifetimes() {
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">//                 +</span>
    <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]; <span class="co">//            +    |</span>
    <span class="kw">let</span> b1 = &amp;v1;           <span class="co">//       +    |    |</span>
    <span class="kw">let</span> b2 = &amp;v2;           <span class="co">//  +    |    |    |</span>
    foo(b1);                <span class="co">//  |    |    |    |  </span>
    foo(b2);                <span class="co">// &#39;b2  &#39;b1  &#39;v2  &#39;v1</span>
                            <span class="co">//  |    |    |    | </span>
}                           <span class="co">//  +    +    +    +</span>

<span class="kw">fn</span> foo(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]); }</code></pre></div>
</section><section id="lifetime-nesting" class="slide level2">
<h1>Lifetime nesting</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> lifetime_nesting() {
    <span class="kw">fn</span> read(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]); }
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];         <span class="co">//                      +</span>
    <span class="kw">let</span> b1;                         <span class="co">//                      |</span>
    {                               <span class="co">//                      |</span>
        <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>];     <span class="co">//                 +    |</span>
        {                           <span class="co">//                 |    |</span>
            <span class="kw">let</span> b2 = &amp;v2;           <span class="co">//  +              |    |</span>
            <span class="kw">let</span> v3 = <span class="pp">vec!</span>[<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>];   <span class="co">//  |         +   &#39;v2  &#39;v1</span>
            b1 = &amp;v1;               <span class="co">// &#39;b2   +   &#39;v3   |    |</span>
            read(b2);               <span class="co">//  |    |    |    |    |</span>
        }                           <span class="co">//  +   &#39;b1   +    |    |  </span>
    }                               <span class="co">//       |         +    |  </span>
    read(b1);                       <span class="co">//       |              | </span>
}                                   <span class="co">//       +              +</span></code></pre></div>
</section><section id="borrow-checking-prevents-errors" class="slide level2" data-transition="fade-out">
<h1>Borrow Checking Prevents Errors</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="kw">fn</span> borrow_checking_prevents_errors() {
    <span class="kw">fn</span> read(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]); }
    <span class="kw">fn</span> consume(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { }
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];      <span class="co">//        +</span>
                                 <span class="co">//        |</span>
    <span class="kw">let</span> b1 = &amp;v1;                <span class="co">//  +    &#39;v1</span>
                                 <span class="co">//  |     |</span>
    consume(v1);                 <span class="co">// &#39;b1   (moved)</span>
    read(b1);                    <span class="co">//  |</span>
}                                <span class="co">//  +</span></code></pre></div>
<pre class="fragment"><code>error: cannot move out of `v1` because it is borrowed
    consume(v1);                 // &#39;b1   (moved)
            ^~
note: borrow of `v1` occurs here
    let b1 = &amp;v1;                //  +    &#39;v1
              ^~</code></pre>
</section><section id="lifetimes-and-lexical-scope" class="slide level2" data-transition="fade-in">
<h1>Lifetimes and Lexical Scope</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="kw">fn</span> borrow_checking_may_seem_simple_minded() {
    <span class="kw">fn</span> read(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]); }
    <span class="kw">fn</span> consume(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { }
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];      <span class="co">//        +</span>
                                 <span class="co">//        |</span>
    <span class="kw">let</span> b1 = &amp;v1;                <span class="co">//  +    &#39;v1</span>
                                 <span class="co">//  |     |</span>
    consume(v1);                 <span class="co">// &#39;b1   (moved)</span>
    <span class="co">// (no call to read)         //  |</span>
}                                <span class="co">//  +</span></code></pre></div>
<pre><code>error: cannot move out of `v1` because it is borrowed
    consume(v1);                 // &#39;b1   (moved)
            ^~
note: borrow of `v1` occurs here
    let b1 = &amp;v1;                //  +    &#39;v1
              ^~</code></pre>
</section><section id="lifetimes-nonetheless-nontrivial" class="slide level2" data-transition="fade-out">
<h1>Lifetimes: Nonetheless Nontrivial</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> copying_can_extend_a_borrows_lifetime() {
    <span class="kw">fn</span> foo(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]);
    }
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">//         +</span>
    <span class="kw">let</span> b2 = {              <span class="co">//         |</span>
        <span class="kw">let</span> b1 = &amp;v1;       <span class="co">//  +      |</span>
        <span class="co">//       ^~~        //  |      |</span>
        foo(b1);            <span class="co">// &#39;b1     |</span>
        b1                  <span class="co">//  |     &#39;v1</span>
    };                      <span class="co">//  +  +   |</span>
                            <span class="co">//     |   |</span>
    foo(b2);                <span class="co">//    &#39;b2  |</span>
                            <span class="co">//     |   |</span>
}                           <span class="co">//     +   +</span></code></pre></div>
</section><section id="lifetimes-nonetheless-nontrivial-1" class="slide level2" data-transition="fade-in">
<h1>Lifetimes: Nonetheless Nontrivial</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> copying_can_extend_a_borrows_lifetime() {
    <span class="kw">fn</span> foo(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]);
    }
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">//         +</span>
    <span class="kw">let</span> b2 = {              <span class="co">//         |</span>
        <span class="kw">let</span> b1 = &amp;<span class="ot">&#39;a</span> v1;    <span class="co">//  +      |</span>
        <span class="co">//       ^~~~~~     //  |      |</span>
        foo(b1);<span class="co">//  |       // &#39;b1     |</span>
        b1      <span class="co">// (caveat) //  |     &#39;v1 == &#39;a</span>
    };                      <span class="co">//  +  +   |</span>
                            <span class="co">//     |   |</span>
    foo(b2);                <span class="co">//    &#39;b2  |</span>
                            <span class="co">//     |   |</span>
}                           <span class="co">//     +   +</span></code></pre></div>
</section><section id="lifetime-bindings-1" class="slide level2">
<h1>Lifetime Bindings 1</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> explicit_lifetime_binding_1() {
    <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>&gt;(ints: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ints[<span class="dv">1</span>]);
    }
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    print(&amp;v1)
}</code></pre></div>
</section><section id="lifetime-bindings-2" class="slide level2" data-transition="fade-out">
<h1>Lifetime Bindings 2</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> explicit_lifetime_binding_2() {
    <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);

    }
    <span class="kw">let</span> one = <span class="dv">1</span>;
    <span class="kw">let</span> two = <span class="dv">2</span>;
    <span class="kw">let</span> three = <span class="dv">3</span>;
    <span class="kw">let</span> four = <span class="dv">4</span>;
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    print(&amp;v1)
}</code></pre></div>
</section><section id="lifetime-bindings-3" class="slide level2" data-transition="fade">
<h1>Lifetime Bindings 3</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> explicit_lifetime_binding_3() {
    <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);
        ptrs.push(ptr);
    }
    <span class="kw">let</span> one = <span class="dv">1</span>;
    <span class="kw">let</span> two = <span class="dv">2</span>;
    <span class="kw">let</span> three = <span class="dv">3</span>;
    <span class="kw">let</span> four = <span class="dv">4</span>;
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    print(&amp;<span class="kw">mut</span> v1, &amp;four);
}</code></pre></div>
</section><section id="lifetime-bindings-4" class="slide level2" data-transition="fade-in">
<h1>Lifetime Bindings 4</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> explicit_lifetime_binding_4() {
    <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);<span class="co">//~~~            ~~~</span>
        ptrs.push(ptr);            <span class="co">//   |              |</span>
    }                              <span class="co">// this must match that,</span>
    <span class="kw">let</span> one = <span class="dv">1</span>;                   <span class="co">// otherwise push is bogus</span>
    <span class="kw">let</span> two = <span class="dv">2</span>;
    <span class="kw">let</span> three = <span class="dv">3</span>;
    <span class="kw">let</span> four = <span class="dv">4</span>;
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    print(&amp;<span class="kw">mut</span> v1, &amp;four);
}</code></pre></div>
</section><section id="lifetime-bindings-5" class="slide level2" data-transition="fade-in">
<h1>Lifetime Bindings 5</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> explicit_lifetime_binding_5() {
    <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>, <span class="ot">&#39;c</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;c</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);  <span class="co">//  ~~~            ~~~</span>
        ptrs.push(ptr);                <span class="co">//   |              |</span>
    }                                  <span class="co">// this must match that,</span>
    <span class="kw">let</span> one = <span class="dv">1</span>;                       <span class="co">// otherwise push is bogus</span>
}</code></pre></div>
<pre class="fragment"><code>error: cannot infer an appropriate lifetime for automatic coercion due to conflicting requirements
        ptrs.push(ptr);
                  ^~~
help: consider using an explicit lifetime parameter as shown:
    fn print&lt;&#39;a, &#39;b&gt;(ptrs: &amp;&#39;a mut Vec&lt;&amp;&#39;b i32&gt;, ptr: &amp;&#39;b i32)</code></pre>
</section><section id="borrowed-return-values." class="slide level2">
<h1>Borrowed return values.</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> borrowed_return_values() {
    <span class="kw">fn</span> first_and_last&lt;<span class="ot">&#39;a</span>&gt;(ints: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; (&amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>, &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>) {
        (&amp;ints[<span class="dv">0</span>], &amp;ints[ints.len() - <span class="dv">1</span>])
    }
}</code></pre></div>
<p>TODO: Exercise idea: Try to write <code>fn first_and_last_mut</code>. Why is it impossible in general?</p>
</section><section class="slide level2">

<p>How about:</p>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> borrowed_return_values_bad() {
    <span class="kw">fn</span> first_and_last&lt;<span class="ot">&#39;a</span>&gt;(ints: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; (&amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>, &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>) {
        (&amp;ints[<span class="dv">0</span>], &amp;ints[ints.len() - <span class="dv">1</span>])
    }
}</code></pre></div>
<p>Why doesn't this work?</p>
<pre class="fragment"><code>error: `ints` does not live long enough
        (&amp;ints[0], &amp;ints[ints.len() - 1])
          ^~~~
note: reference must be valid for the lifetime &#39;a ...
note: ...but borrowed value is only valid for the scope of
note:    parameters for function</code></pre>
</section><section id="lifetime-elision-1" class="slide level2" data-transition="fade-out">
<h1>Lifetime Elision 1</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> lifetime_elision_1() {
    <span class="kw">fn</span> print1&lt;<span class="ot">&#39;a</span>&gt;(ints: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ints[<span class="dv">1</span>]);
    }
    <span class="kw">fn</span> print2&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);

    }
    <span class="kw">fn</span> print3&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);
        ptrs.push(ptr);
    }
}</code></pre></div>
</section><section id="lifetime-elision-2" class="slide level2" data-transition="fade">
<h1>Lifetime Elision 2</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> lifetime_elision_2() {
    <span class="kw">fn</span> print1    (ints: &amp;   <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ints[<span class="dv">1</span>]);
    }
    <span class="kw">fn</span> print2        (ptrs: &amp;   <span class="dt">Vec</span>&lt;&amp;   <span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);

    }
    <span class="kw">fn</span> print3&lt;    <span class="ot">&#39;b</span>&gt;(ptrs: &amp;   <span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);
        ptrs.push(ptr);
    }
}</code></pre></div>
</section><section id="lifetime-elision-3" class="slide level2" data-transition="fade-in">
<h1>Lifetime Elision 3</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> lifetime_elision_3() {
    <span class="kw">fn</span> print1(ints: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ints[<span class="dv">1</span>]);
    }
    <span class="kw">fn</span> print2(ptrs: &amp;<span class="dt">Vec</span>&lt;&amp;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);

    }
    <span class="kw">fn</span> print3&lt;<span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);
        ptrs.push(ptr);
    }
}</code></pre></div>
</section><section id="generic-items" class="slide level2">
<h1>Generic items</h1>
</section><section id="generic-items-1" class="slide level2" data-transition="fade-out">
<h1>Generic items 1</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> generic_items_1() {
    <span class="kw">fn</span> push_twice&lt;<span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        ptrs.push(ptr);
        ptrs.push(ptr);
    }
    <span class="kw">let</span> (one, two, three, four) = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>);
    <span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    push_twice(&amp;<span class="kw">mut</span> v, &amp;four);
}</code></pre></div>
<p>This obviously generalizes beyond <code>i32</code>!</p>
</section><section id="generic-items-2" class="slide level2" data-transition="fade-in">
<h1>Generic items 2</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> generic_items_2() {
    <span class="kw">fn</span> push_twice&lt;<span class="ot">&#39;b</span>, T&gt;(ptrs: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> T&gt;, ptr: &amp;<span class="ot">&#39;b</span> T) {
        ptrs.push(ptr);
        ptrs.push(ptr);
    }
    <span class="kw">let</span> (one, two, three, four) = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>);
    <span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    push_twice(&amp;<span class="kw">mut</span> v, &amp;four);
}</code></pre></div>
<p>This is going so smoothly; lets try printing <code>v_1</code> again!</p>
</section><section id="generic-items-3" class="slide level2">
<h1>Generic items 3</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> generic_items_3() {
    <span class="kw">fn</span> push_twice&lt;<span class="ot">&#39;b</span>, T&gt;(ptrs: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> T&gt;, ptr: &amp;<span class="ot">&#39;b</span> T) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);
        ptrs.push(ptr);
        ptrs.push(ptr);
    }
    <span class="kw">let</span> (one, two, three, four) = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>);
    <span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    push_twice(&amp;<span class="kw">mut</span> v, &amp;four);
}</code></pre></div>
<pre class="fragment"><code>error: trait `core::fmt::Display` not implemented for the type `T`
        println!(&quot;v_1: {}&quot;, ptrs[1]);
                            ^~~~~~~</code></pre>
<p>(Reminder: Rust is not C++)</p>
</section><section id="trait-bounded-polymorphism" class="slide level2">
<h1>Trait-bounded polymorphism</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Dimensioned {
    <span class="kw">fn</span> height(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span>;
    <span class="kw">fn</span> width(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span>;
}

<span class="kw">fn</span> stacked_height&lt;S&gt;(v: &amp;[S]) -&gt; <span class="dt">u32</span> <span class="kw">where</span> S: Dimensioned {
    <span class="kw">let</span> <span class="kw">mut</span> accum = <span class="dv">0</span>;
    <span class="kw">for</span> s <span class="kw">in</span> v { accum += s.height() }
    accum
}</code></pre></div>
</section><section id="trait-impls" class="slide level2">
<h1>Trait Impls</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Rect { w: <span class="dt">u32</span>, h: <span class="dt">u32</span> }
<span class="kw">struct</span> Circle { r: <span class="dt">u32</span> }

<span class="kw">impl</span> Dimensioned <span class="kw">for</span> Rect {
    <span class="kw">fn</span> height(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span> { <span class="kw">self</span>.h }
    <span class="kw">fn</span> width(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span> { <span class="kw">self</span>.w }
}
    
<span class="kw">impl</span> Dimensioned <span class="kw">for</span> Circle {
    <span class="kw">fn</span> height(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span> { <span class="kw">self</span>.r * <span class="dv">2</span> }
    <span class="kw">fn</span> width(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span> { <span class="kw">self</span>.r * <span class="dv">2</span> }
}</code></pre></div>
</section><section id="traits-in-action" class="slide level2">
<h1>Traits in Action</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Rect {
    <span class="kw">fn</span> square(l: <span class="dt">u32</span>) -&gt; Rect { Rect { w: l, h: l } }
}
<span class="kw">impl</span> Circle {
    <span class="kw">fn</span> with_radius(r: <span class="dt">u32</span>) -&gt; Circle { Circle { r: r } }
}

<span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> trait_bounded_polymorphism() {
    <span class="kw">let</span> squares = [ Rect::square(<span class="dv">1</span>), Rect::square(<span class="dv">2</span>) ];
    <span class="kw">let</span> circles = [ Circle::with_radius(<span class="dv">1</span>), Circle::with_radius(<span class="dv">2</span>)];
    <span class="pp">assert_eq!</span>(stacked_height(&amp;squares), <span class="dv">3</span>);
    <span class="pp">assert_eq!</span>(stacked_height(&amp;circles), <span class="dv">6</span>);
}</code></pre></div>
</section><section id="generics-do-not-suffice" class="slide level2">
<h1>Generics do not suffice</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> parametric_fail() {
    <span class="kw">let</span> shapes = [Rect::square(<span class="dv">1</span>), Circle::with_radius(<span class="dv">2</span>)];
    <span class="pp">assert_eq!</span>(stacked_height(&amp;shapes), <span class="dv">5</span>);
}</code></pre></div>
<pre class="fragment"><code>error: mismatched types:
 expected `Rect`,
    found `Circle`
    let shapes = [Rect::square(1), Circle::with_radius(2)];
                                   ^~~~~~~~~~~~~~~~~~~~~~</code></pre>
</section><section id="monomorphization-is-why" class="slide level2">
<h1>Monomorphization is why</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="kw">struct</span> Rect { w: <span class="dt">u32</span>, h: <span class="dt">u32</span> }
<span class="kw">struct</span> Circle { r: <span class="dt">u32</span> }

<span class="kw">fn</span> parametric_fail() {
    <span class="kw">let</span> shapes = [Rect::square(<span class="dv">1</span>), Circle::with_radius(<span class="dv">2</span>)];
    <span class="co">//  ~~~~~~    ~~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~</span>
    <span class="co">//    |              |                    |</span>
    <span class="co">//    |       This is 8 bytes     This is 4-bytes</span>
    <span class="co">//    |</span>
    <span class="co">//  There&#39;s no uniform array</span>
    <span class="co">//  type to hold both in-line.</span>
}</code></pre></div>
</section><section id="this-is-a-job-for-..." class="slide level2">
<h1>This is a job for ...</h1>
<h3 id="object-oriented-programming" class="fragment">Object-Oriented Programming!</h3>
</section><section id="traits-as-objects-1" class="slide level2">
<h1>Traits as Objects 1</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> stacked_obj_refs(v: &amp;[&amp;Dimensioned]) -&gt; <span class="dt">u32</span> {
    <span class="kw">let</span> <span class="kw">mut</span> accum = <span class="dv">0</span>;
    <span class="kw">for</span> s <span class="kw">in</span> v { accum += s.height() }
    accum
}

<span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_objs_1() {
    <span class="kw">let</span> r = Rect::square(<span class="dv">1</span>);
    <span class="kw">let</span> c = Circle::with_radius(<span class="dv">2</span>);
    <span class="kw">let</span> shapes: [&amp;Dimensioned; <span class="dv">2</span>] = [&amp;r, &amp;c];
    <span class="pp">assert_eq!</span>(stacked_obj_refs(&amp;shapes), <span class="dv">5</span>);
}</code></pre></div>
</section><section id="traits-as-objects-2" class="slide level2">
<h1>Traits as Objects 2</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> stacked_obj_boxes(v: &amp;[<span class="dt">Box</span>&lt;Dimensioned&gt;]) -&gt; <span class="dt">u32</span> {
    <span class="kw">let</span> <span class="kw">mut</span> accum = <span class="dv">0</span>;
    <span class="kw">for</span> s <span class="kw">in</span> v { accum += s.height() }
    accum
}

<span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_objs_2() {
    <span class="kw">let</span> shapes: [<span class="dt">Box</span>&lt;Dimensioned&gt;; <span class="dv">2</span>] =
        [<span class="dt">Box</span>::new(Rect::square(<span class="dv">1</span>)), <span class="dt">Box</span>::new(Circle::with_radius(<span class="dv">2</span>))];
    <span class="pp">assert_eq!</span>(stacked_obj_boxes(&amp;shapes), <span class="dv">5</span>);
}</code></pre></div>
</section></section>
<section><section id="part-4-systems-development" class="titleslide slide level1"><h1>Part 4: Systems Development</h1></section><section id="concurrency-send-sync-threadscoped" class="slide level2">
<h1>Concurrency: <code>Send</code>, <code>Sync</code>, <code>thread::scoped</code></h1>
</section><section id="io-in-rust-try" class="slide level2">
<h1>I/O in Rust, <code>try!</code></h1>
</section><section id="concurrency-threadspawn-channels" class="slide level2">
<h1>Concurrency: <code>thread::spawn</code>, channels</h1>
</section><section id="unsafe-code-ffi" class="slide level2">
<h1>unsafe code, FFI</h1>
</section><section id="rust-in-gecko-demonstration" class="slide level2">
<h1>Rust in Gecko (demonstration)</h1>
</section></section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,         // Display controls in the bottom right corner
        progress: true,         // Display a presentation progress bar
        history: true,          // Push each slide change to the browser history
        center: true,                       // Vertical centering of slides
        maxScale: 1.5,                  // Bounds for smallest/largest possible content scale
        slideNumber: false,                // Display the page number of the current slide
        theme: 'black', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
