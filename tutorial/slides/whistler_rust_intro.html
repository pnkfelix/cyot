<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Felix and the Rust Team" />
  <title>Rust Intro</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.css"/>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #dddddd; }
td.sourceCode { padding-left: 5px; }
code > span.kw { font-weight: bold; } /* Keyword */
code > span.dt { color: #800000; } /* DataType */
code > span.dv { color: #0000ff; } /* DecVal */
code > span.bn { color: #0000ff; } /* BaseN */
code > span.fl { color: #800080; } /* Float */
code > span.ch { color: #ff00ff; } /* Char */
code > span.st { color: #dd0000; } /* String */
code > span.co { color: #808080; font-style: italic; } /* Comment */
code > span.al { color: #00ff00; font-weight: bold; } /* Alert */
code > span.fu { color: #000080; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #ff0000; font-weight: bold; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #ff00ff; } /* SpecialChar */
code > span.vs { color: #dd0000; } /* VerbatimString */
code > span.ss { color: #dd0000; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { } /* ControlFlow */
code > span.op { } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { font-weight: bold; } /* Preprocessor */
code > span.at { } /* Attribute */
code > span.do { color: #808080; font-style: italic; } /* Documentation */
code > span.an { color: #808080; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #808080; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #808080; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
  <link rel="stylesheet" href="../../slide-style.css"/>
  <link rel="stylesheet" href="../../code-style.css"/>
  <!-- If the query includes 'print-pdf', include the PDF print sheet -->
  <script>
    if( window.location.search.match( /print-pdf/gi ) ) {
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = 'reveal.js/css/print/pdf.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Rust Intro</h1>
    <h2 class="author">Felix and the Rust Team</h2>
    <h3 class="date">25 June 2015; <a href="http://bit.ly/1N93I0P" class="uri">http://bit.ly/1N93I0P</a></h3>
</section>

<section><section id="rust-what-why-how" class="titleslide slide level1"><h1>Rust: What? Why? (How?)</h1></section><section id="goals-for-today" class="slide level2">
<h1>Goals for today</h1>
<ul>
<li>Convince you Rust is awesome</li>
<li>Provide seeds of knowledge
<ul>
<li>One can only cultivate so much during a three hour window</li>
</ul></li>
</ul>
</section><section id="these-slides" class="slide level2">
<h1>These slides</h1>
<p><a href="http://bit.ly/1N93I0P" class="uri">http://bit.ly/1N93I0P</a></p>
<p>~</p>
<p><a href="http://pnkfelix.github.io/cyot/tutorial/slides/whistler_rust_intro.html" class="uri">http://pnkfelix.github.io/cyot/tutorial/slides/whistler_rust_intro.html</a></p>
</section><section id="goals-for-rust" class="slide level2">
<h1>Goals for Rust</h1>
<ul>
<li><p>Safe. Concurrent. Fast.</p></li>
<li>Specifics
<ul>
<li>Abstraction without overhead</li>
<li>Memory safety without garbage collection</li>
<li>Concurrency without data races</li>
</ul></li>
<li><p>Generalization: HACK WITHOUT FEAR!</p></li>
</ul>
</section><section id="a-taste" class="slide level2">
<h1>A taste</h1>
<ul>
<li>Three fast <em>&quot;amuse bouches&quot;</em>
<ul>
<li>not the main course</li>
<li>(not even an appetizer)</li>
</ul></li>
</ul>
</section><section id="abstraction-without-overhead" class="slide level2" data-transition="fade-out">
<h1>Abstraction without overhead</h1>
<p>The below <a href="https://play.rust-lang.org/?gist=23a69161dd4421e2925f">loop demo</a> compiles down to tight code:</p>
<!--
```rust
#[allow(dead_code)]
fn main() {
    let v1: Vec<i32> = (-100..10).collect();
    let s1 = sum_pos(&v1);
    let v2: Vec<i32> = (-100..1000).collect();
    let s2 = sum_pos(&v2);
    println!("v1.len: {} s1: {} v2.len: {} s2: {}", v1.len(), s1, v2.len(), s2);
}

#[allow(dead_code)]
#[inline(never)]
```
-->
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// sums all the positive values in `v`</span>
<span class="kw">fn</span> sum_pos(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; <span class="dt">i32</span> {
    <span class="kw">let</span> <span class="kw">mut</span> sum = <span class="dv">0</span>;
    <span class="kw">for</span> i <span class="kw">in</span> v.iter().filter(|i| **i &gt; <span class="dv">0</span>) {
        sum += *i;
    }
    sum
}</code></pre></div>
</section><section id="abstraction-without-overhead-1" class="slide level2" data-transition="fade-in">
<h1>Abstraction without overhead</h1>
<p>Generated x86_64 machine code for <code class="sourceCode rust"><span class="kw">fn</span> sum_pos</code>:</p>
<div class="sourceCode"><pre class="sourceCode nasm"><code class="sourceCode nasm">    leaq    (<span class="ot">%rdi,%rsi,4), %rcx</span>
    xorl    <span class="ot">%eax, %eax</span>
    <span class="kw">jmp</span> .LBB5_1
<span class="fu">.LBB5_3:</span>
    addl    <span class="ot">%edx, %eax</span>
    .<span class="kw">align</span>  <span class="dv">16</span><span class="bn">, 0x90</span>
<span class="fu">.LBB5_1:</span>
    cmpq    <span class="ot">%rdi, %rcx</span>
    <span class="kw">je</span>  .LBB5_4
    movl    (<span class="ot">%rdi), %edx</span>
    addq<span class="bn">    $4, </span><span class="ot">%rdi</span>
    testl   <span class="ot">%edx, %edx</span>
    <span class="kw">jle</span> .LBB5_1
    <span class="kw">jmp</span> .LBB5_3
<span class="fu">.LBB5_4:</span>
    retq</code></pre></div>
<p>(when compiled in &quot;release mode&quot;)</p>
</section><section id="memory-safety" class="slide level2">
<h1>Memory safety</h1>
<p>Example: catches iterator invalidation bugs</p>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="kw">fn</span> this_wont_compile(v: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; <span class="dt">i32</span> {
    <span class="kw">let</span> <span class="kw">mut</span> sum = <span class="dv">0</span>;
    <span class="kw">for</span> &amp;i <span class="kw">in</span> v.iter() {
        sum += i;
        <span class="kw">if</span> i &gt; <span class="dv">0</span> { v.push(<span class="dv">0</span>); }
        <span class="co">//         ~~~~~~~~~ invalid! (might realloc</span>
        <span class="co">//                   the backing storage for `v`)</span>
    }
    sum
}</code></pre></div>
<pre class="fragment"><code>error: cannot borrow `*v` as mutable because it is also borrowed
       as immutable
        if i &gt; 0 { v.push(0); }
                   ^
note: previous borrow of `*v` occurs here; the immutable borrow
      prevents subsequent moves or mutable borrows of `*v` until
      the borrow ends
    for &amp;i in v.iter() {
              ^</code></pre>
</section><section id="slick-fearless-concurrency" class="slide level2">
<h1>Slick, Fearless Concurrency</h1>
<p>See also <a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Fearless Concurrency</a> blog post.</p>
<!--
```rust
fn seq_max(partial_data: &[u8]) -> u8 {
    *partial_data.iter().max().unwrap()
}
```
-->
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
<span class="kw">fn</span> par_max(data: &amp;[<span class="dt">u8</span>]) -&gt; <span class="dt">u8</span> {
    <span class="kw">if</span> data.len() &lt;= <span class="dv">4</span> { <span class="kw">return</span> seq_max(data); }
    <span class="kw">let</span> len_4 = data.len() / <span class="dv">4</span>; <span class="co">// DATA = [A .., B .., C .., D..]</span>
    <span class="kw">let</span> (q1, rest) = data.split_at(len_4);    <span class="co">// (A.. \ B..C..D..)</span>
    <span class="kw">let</span> (q2, rest) = rest.split_at(len_4);    <span class="co">//  (B.. \ C..D..)</span>
    <span class="kw">let</span> (q3, q4)   = rest.split_at(len_4);    <span class="co">//   (C.. \ D..)</span>
    <span class="kw">let</span> t1 = thread::scoped(|| seq_max(q1));  <span class="co">// fork A..</span>
    <span class="kw">let</span> t2 = thread::scoped(|| seq_max(q2));  <span class="co">// fork B..</span>
    <span class="kw">let</span> t3 = thread::scoped(|| seq_max(q3));  <span class="co">// fork C..</span>
    <span class="kw">let</span> v4 = seq_max(q4);                     <span class="co">// compute D..</span>
    <span class="kw">let</span> (v1, v2, v3) = (t1.join(), t2.join(), t3.join()); <span class="co">// join!</span>
    <span class="kw">return</span> seq_max(&amp;[v1, v2, v3, v4]);
}</code></pre></div>
<p>(caveat: above is using unstable <code>thread::scoped</code> API)</p>
<!--
```rust
#[test]
fn hi() {
    let mut v = vec![2, 1, 10, 9, 8, 7, 6, 5, 4, 3];
    let m = par_max(&v);
    assert_eq!(m, 10);
}
```
-->
</section></section>
<section><section id="part-1-play" class="titleslide slide level1"><h1>Part 1: Play</h1></section><section id="language-and-api-docs" class="slide level2">
<h1>Language and API docs</h1>
<ul>
<li><p>All linked from top of <a href="http://www.rust-lang.org/" class="uri">http://www.rust-lang.org/</a></p></li>
<li>Starting points
<ul>
<li>The Book: <a href="https://doc.rust-lang.org/stable/book/" class="uri">https://doc.rust-lang.org/stable/book/</a></li>
<li>Standard API: <a href="https://doc.rust-lang.org/stable/std/" class="uri">https://doc.rust-lang.org/stable/std/</a></li>
</ul></li>
</ul>
</section><section id="playpen" class="slide level2">
<h1>Playpen</h1>
<ul>
<li>For now, open <a href="http://play.rust-lang.org/"><code>http://play.rust-lang.org/</code></a> in a web browser.</li>
</ul>
<ul>
<li>For later: Install Rust from the USB stick when it comes to you</li>
</ul>
</section><section id="outline-for-tutorial" class="slide level2">
<h1>Outline for Tutorial</h1>
<ul>
<li>Goals</li>
<li>Ownership and Borrowing; Arrays and Strings</li>
<li>Local Development: Cargo; Crates and Modules</li>
<li>More Fundamentals: Data; More on Borrowing; Traits</li>
<li>Systems Development: Concurrency and I/O; FFI</li>
</ul>
<!--
## Test slide

```rust
// 01

//000000011111111112222222222333333333344444444445555555555666666666677777777778
//345678901234567890123456789012345678901234567890123456789012345678901234567890
// 05




// 10


// 13
// 14
// 15
// 16
// 17
// 18
// 19
// 20
// 21
// 22
// 23
// 24
// 25
```
-->
</section><section id="lets-dive-in" class="slide level2">
<h1>Lets dive in</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> main() {
    <span class="pp">println!</span>(<span class="st">&quot;Hello World!&quot;</span>); <span class="co">// (`foo!` means macro)</span>
    print_ten();                                               
}

<span class="kw">fn</span> print_ten() {
    <span class="pp">println!</span>(<span class="st">&quot;Ten: {}&quot;</span>, <span class="dv">10</span>);
    <span class="co">//             ~~   ~~</span>
    <span class="co">//             |     | </span>
    <span class="co">//    placeholder   argument</span>
}</code></pre></div>
<!--
## Usual stuff

  * Local variables: `let x = 3;`{.rust}
    * Optional type annotations: `let x: i32 = 3;`{.rust}

  * If expressions:
    `if test { then(); also() } else { other() }`{.rust}

  * Loops: `while test { first(); second(); ... }`{.rust}
    * Also `for i in iterator { f(); g(); ... }`{.rust}

  * Standalone functions:

    ```rust
    fn add8(x: i32) -> i32 {
        println!("add8");
        return x + 8;
    }
    ```

## Unusual stuff 1

  * Blocks have optional tail expressions
  * Tuples, Pattern binding
  * Algebraic Data, Pattern matching

``` {.rust}
fn add8(x: i32) -> i32 { return x + 8; }
fn add8(x: i32) -> i32 { x + 8 }
```

``` {.rust}
let (x, y): (i32, i32) = int_pair;
(x + 8, y + 8)
```

``` {.rust}
let v = match number_result {
    Ok(x)  => x + 8,
    Err(e) => { println!("error: {}", e); break; }
};
```

## Unusual stuff 2

  * Generics, Trait Bounds
  * Objects via Traits
  * Ownership and Borrowing

  We start with *Ownership and Borrowing*;
  a critical concept for understanding Rust.

-->
</section><section id="a-really-big-idea" class="slide level2">
<h1>A really big idea</h1>
</section></section>
<section><section id="ownership-and-move-semantics" class="titleslide slide level1"><h1>Ownership and Move Semantics</h1></section><section id="creation-and-consumption" class="slide level2">
<h1>Creation and Consumption</h1>
<p>Once initialized, local owns its data (vector's backing store)</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">pub</span> <span class="kw">fn</span> create_owned() {
    <span class="kw">let</span> <span class="kw">mut</span> vec = <span class="dt">Vec</span>::new();         <span class="co">//  + (`vec` initialized)</span>
    vec.push(<span class="dv">2000</span>);                   <span class="co">//  |   ... and</span>
    vec.push( <span class="dv">400</span>);                   <span class="co">//  |        also</span>
    vec.push(  <span class="dv">60</span>);                   <span class="co">//  |         modified ...</span>
    <span class="pp">println!</span>(<span class="st">&quot;vec: {:?}&quot;</span>, vec);       <span class="co">//  |</span>
    <span class="kw">let</span> the_sum = sum(vec);           <span class="co">// (... and moved)</span>
    <span class="pp">println!</span>(<span class="st">&quot;the_sum: {}&quot;</span>, the_sum); 
}</code></pre></div>
<p>At scope end, initialized variables are cleaned up</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> sum(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; <span class="dt">i32</span> {          <span class="co">//  +</span>
   <span class="kw">let</span> <span class="kw">mut</span> accum = <span class="dv">0</span>;                 <span class="co">//  |</span>
   <span class="kw">for</span> i <span class="kw">in</span> v.iter() { accum += *i; } <span class="co">//  |</span>
   accum <span class="co">// (p.s. where is `return`?) //  |</span>
}                                     <span class="co">//  + (`v` destroyed/freed)</span></code></pre></div>
</section><section id="move-vs-copy" class="slide level2">
<h1>Move vs Copy</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_owned_vs_copied() {
    <span class="kw">let</span> moving_value = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    <span class="kw">let</span> copied_value = <span class="dv">17</span>;
    <span class="kw">let</span> tuple = (moving_value, copied_value);

    <span class="pp">println!</span>(<span class="st">&quot;copied_value: {:?}&quot;</span>, copied_value);
    <span class="pp">println!</span>(<span class="st">&quot;moving_value: {:?}&quot;</span>, moving_value);
}</code></pre></div>
<pre class="compile_error fragment"><code>error: use of moved value: `moving_value` [E0382]
    println!(&quot;moving_value: {:?}&quot;, moving_value);
                                   ^~~~~~~~~~~~

note: `moving_value` moved here because it has type
      `collections::vec::Vec&lt;i32&gt;`, which is non-copyable
    let tuple = (moving_value, copied_value);
                 ^~~~~~~~~~~~</code></pre>
<!--
----

* Consider assignment
    ``` {.rust}
    left_side = right_side;
    ```

  * Owned data
    * *moves* `right_side` into `left_side`
    * `right_side` becomes inaccessible
    * one can still opt into explicit duplication,
      e.g. '`new = owned.clone();`{.rust}'

  * Copied data
    * *memcpy's* `right_side` into `left_side`
    * one can freely keep using the original

-->
</section></section>
<section><section id="exercises" class="titleslide slide level1"><h1>Exercises</h1></section><section id="exercises-1" class="slide level2">
<h1>Exercises 1</h1>
<p><a href="http://pnkfelix.github.io/cyot/tutorial/exercises/ex_part_1.html" class="uri">http://pnkfelix.github.io/cyot/tutorial/exercises/ex_part_1.html</a></p>
</section></section>
<section><section id="borrowing" class="titleslide slide level1"><h1>Borrowing</h1></section><section id="moves-insufficient-on-their-own" class="slide level2">
<h1>Moves insufficient on their own</h1>
<p>Imagine programming without reuse</p>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> moves_insufficient() {
    <span class="kw">let</span> vec = expensive_vector_computation();

    <span class="kw">let</span> result1 = some_vec_calculation(vec); <span class="co">// &lt;-- `vec` moved here</span>

    <span class="kw">let</span> result2 = other_calculation(vec); <span class="co">// oops, `vec` is *gone*</span>

    combine(result1, result2);

}</code></pre></div>
<!--
fn expensive_vector_computation() -> Vec<i32> { vec![] }
fn some_vec_calculation<T>(t: T) { }
fn other_calculation<T>(t: T) { }
fn combine(x: (), y: ()) { }
-->
<pre class="fragment"><code>error: use of moved value: `vec` [E0382]
    let result2 = other_calculation(vec); // oops
                                    ^~~
note: `vec` moved here because it has type
      `collections::vec::Vec&lt;i32&gt;`, which is non-copyable
    let result1 = some_vec_calculation(vec); // &lt;-- `vec` moved here
                                       ^~~</code></pre>
</section><section id="want-access-to-owned-data-without-consuming-it" class="slide level2">
<h1>Want: access to owned data <em>without</em> consuming it</h1>
</section><section id="thus-borrowing" class="slide level2">
<h1>Thus, &quot;borrowing&quot;</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> moves_insufficient() {
    <span class="kw">let</span> vec = expensive_vector_computation();

    <span class="kw">let</span> result1 = some_vec_calculation(&amp;vec); <span class="co">// &lt;-- lend out `vec`</span>

    <span class="kw">let</span> result2 = other_calculation(&amp;vec); <span class="co">// &lt;-- lend again, no prob</span>

    combine(result1, result2);

} <span class="co">// (`vec` is destroyed/freed aka &quot;dropped&quot; here)</span></code></pre></div>
<pre class="fragment"><code>                                    &amp;vec
                                    ~~~~
                                      |
                              a borrow expression</code></pre>
<div class="fragment">
<p>(&quot;mo' features, mo' problems&quot;)</p>
</div>
</section><section id="big-question" class="slide level2">
<h1>Big Question</h1>
<ul>
<li>Why are safety violations generally hard to detect?</li>
</ul>
<div class="fragment">
<ul>
<li><p>It is due to <em>aliasing</em></p></li>
<li><p>Borrows <em>reintroduce</em> aliasing</p></li>
</ul>
<h3 id="q-how-to-ensure-safety-in-presence-of-aliasing" class="fragment">Q: How to ensure safety in presence of aliasing?</h3>
<h3 id="a-restrict-the-aliasing" class="fragment">A: Restrict the aliasing</h3>
</div>
</section><section id="simple-metaphor-rw-lock" class="slide level2">
<h1>Simple metaphor: RW lock</h1>
<ul>
<li><p>Read-only operations do not require exclusive access</p></li>
<li><p>Exclusive access requires there are no other readers</p></li>
</ul>
<p>Rust uses analogous model (at compile-time) for borrows</p>
</section><section id="borrowing-basic-mental-model" class="slide level2 left_align">
<h1>Borrowing: Basic Mental Model</h1>
<div class="fragment">
<ul>
<li>Base types <code class="sourceCode rust">T</code>
<ul>
<li>e.g. <code class="sourceCode rust"><span class="dt">char</span></code>, <code class="sourceCode rust"><span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;</code></li>
<li>If type copyable, then you can always copy it</li>
<li>You can <em>move</em> it only if no borrow active</li>
</ul></li>
</ul>
</div>
<div class="fragment">
<ul>
<li>Immutable borrows: <code class="sourceCode rust">&amp;T</code>
<ul>
<li>&quot;Read-only.&quot; Freely aliasable; copyable</li>
<li>(i.e. &quot;many readers&quot;)</li>
</ul></li>
</ul>
</div>
<div class="fragment">
<ul>
<li>Mutable borrows: <code class="sourceCode rust">&amp;<span class="kw">mut</span> T</code>
<ul>
<li>Read/Write. Exclusive access; non-copy</li>
<li>(i.e. &quot;at most one writer&quot;)</li>
</ul></li>
</ul>
<!--
  * (Why the quotes? "[interior mutability]")
-->
</div>
</section><section id="immutable-borrows" class="slide level2">
<h1>Immutable borrows</h1>
</section><section id="borrowing-immutably" class="slide level2" data-transition="fade-out">
<h1>Borrowing (immutably)</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> show_some_borrows() {

    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>];

    <span class="kw">let</span> r1 = &amp;v1;
    <span class="kw">let</span> r2 = &amp;v2;
    foo(r1);
    foo(r2);

}</code></pre></div>
<!-- -->
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">&#39;a</span>&gt;(v: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]); }</code></pre></div>
<p><code>&amp;v1</code> and <code>&amp;v2</code> are <em>borrowing</em> <code>v1</code> and <code>v2</code>.</p>
</section><section id="scopes-and-lifetimes" class="slide level2" data-transition="fade-in">
<h1>Scopes and Lifetimes</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> show_some_lifetimes() {

    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">//                 +</span>
    <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]; <span class="co">//            +    |</span>
                            <span class="co">//            |    |</span>
    <span class="kw">let</span> r1 = &amp;v1;           <span class="co">//       +    |    |</span>
    <span class="kw">let</span> r2 = &amp;v2;           <span class="co">//  +    |    |    |</span>
    foo(r1);                <span class="co">//  |    |    |    |  </span>
    foo(r2);                <span class="co">// &#39;r2  &#39;r1  &#39;v2  &#39;v1</span>
                            <span class="co">//  |    |    |    | </span>
}                           <span class="co">//  +    +    +    +</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">&#39;a</span>&gt;(v: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]); }</code></pre></div>
<p>Each borrow selects &quot;appropriate&quot; lifetime <code>'a</code>.</p>
</section><section id="borrow-checking-prevents-errors" class="slide level2" data-transition="fade-out">
<h1>Borrow Checking Prevents Errors</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="kw">fn</span> borrow_checking_prevents_errors() {

    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];      <span class="co">//        +</span>
                                 <span class="co">//        |</span>
    <span class="kw">let</span> r1 = &amp;v1;                <span class="co">//  +    &#39;v1</span>
                                 <span class="co">//  |     |</span>
    consume(v1);                 <span class="co">// &#39;r1   (moved)</span>
    foo(r1);                     <span class="co">//  |</span>
}                                <span class="co">//  +</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">fn</span> foo&lt;<span class="ot">&#39;a</span>&gt;(v: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]); }
    <span class="kw">fn</span> consume(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="co">/* `v` *dropped* at scope end */</span> }</code></pre></div>
<p><code>foo(r1)</code> attempts an indirect read of <code>v1</code></p>
<pre class="fragment"><code>error: cannot move out of `v1` because it is borrowed
    consume(v1);
            ^~
note: borrow of `v1` occurs here
    let r1 = &amp;v1;
              ^~</code></pre>
</section><section id="lifetimes-and-lexical-scope" class="slide level2" data-transition="fade-in">
<h1>Lifetimes and Lexical Scope</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="kw">fn</span> borrow_checking_may_seem_simple_minded() {

    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];      <span class="co">//        +</span>
                                 <span class="co">//        |</span>
    <span class="kw">let</span> r1 = &amp;v1;                <span class="co">//  +    &#39;v1</span>
                                 <span class="co">//  |     |</span>
    consume(v1);                 <span class="co">// &#39;r1   (moved)</span>
    <span class="co">// (no call to read)         //  |</span>
}                                <span class="co">//  +</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">fn</span> foo&lt;<span class="ot">&#39;a</span>&gt;(v: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]); }
    <span class="kw">fn</span> consume(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { }</code></pre></div>
<pre><code>error: cannot move out of `v1` because it is borrowed
    consume(v1);
            ^~
note: borrow of `v1` occurs here
    let r1 = &amp;v1;
              ^~</code></pre>
<p>(artifact of lexical-scope based implementation)</p>
</section><section id="built-on-lexical-scopes-but-non-trivial" class="slide level2" data-transition="slide-in fade-out">
<h1>Built on lexical scopes, but non-trivial</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> copying_can_extend_a_borrows_lifetime_1() {
    <span class="kw">fn</span> foo&lt;<span class="ot">&#39;a</span>&gt;(v: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]); }
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">//         +</span>
    <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]; <span class="co">//         |    +</span>
    <span class="kw">let</span> r2 = {              <span class="co">//         |    |</span>
        <span class="kw">let</span> r1 = &amp;v1;       <span class="co">//  +      |    |</span>
        <span class="co">//       ~~~ &lt;--- A //  |      |    |</span>
        foo(r1);            <span class="co">// &#39;r1     |    |</span>
        &amp;v2                 <span class="co">//  |     &#39;v1  &#39;v2</span>
    };                      <span class="co">//  +  +   |    |</span>
    <span class="co">// (maybe mutate `v1`   //     |   |    |</span>
    <span class="co">// here someday?)       //     |   |    |</span>
                            <span class="co">//    &#39;r2  |    |</span>
    foo(r2);                <span class="co">//     |   |    |</span>
}                           <span class="co">//     +   +    +</span></code></pre></div>
<p>How long should the borrow <code>&amp;v1</code> last?</p>
<aside class="notes">
<p>In this case, the borrow marked &quot;A&quot; only needs to last long enough for the call to <code>foo(r1)</code>; after that point, the borrow is never needed.</p>
</aside>
</section><section id="built-on-lexical-scopes-but-non-trivial-1" class="slide level2" data-transition="fade-in slide-out">
<h1>Built on lexical scopes, but non-trivial</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> copying_can_extend_a_borrows_lifetime_2() {
    <span class="kw">fn</span> foo&lt;<span class="ot">&#39;a</span>&gt;(v: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="pp">println!</span>(<span class="st">&quot;v[1]: {}&quot;</span>, v[<span class="dv">1</span>]); }
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">//         +</span>
    <span class="kw">let</span> v2 = <span class="pp">vec!</span>[<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]; <span class="co">//         |    +</span>
    <span class="kw">let</span> r2 = {              <span class="co">//         |    |</span>
        <span class="kw">let</span> r1 = &amp;v1;       <span class="co">//  +      |    |</span>
        <span class="co">//       ~~~ &lt;--- A //  |      |    |</span>
        foo(r1);            <span class="co">// &#39;r1     |    |</span>
        r1  <span class="co">// &lt;--------- B //  |     &#39;v1  &#39;v2</span>
    };                      <span class="co">//  +  +   |    |</span>
    <span class="co">// (maybe mutate `v1`   //     |   |    |</span>
    <span class="co">// here someday?)       //     |   |    |</span>
                            <span class="co">//    &#39;r2  |    |</span>
    foo(r2);                <span class="co">//     |   |    |</span>
}                           <span class="co">//     +   +    +</span></code></pre></div>
<p>How long should the borrow <code>&amp;v1</code> last now?</p>
<aside class="notes">
<p>In this case, the borrow marked &quot;A&quot; needs to last longer! The value of <code>r1</code> is being copied into <code>r2</code> on the line marked &quot;B&quot;, so the borrow marked &quot;A&quot; needs to include the scope of both <code>'r1</code> and <code>'r2</code>.</p>
</aside>
<!--

## Lifetime Nesting  { data-transition="slide" }

```rust
#[test]
fn lifetime_nesting() {
    let v1 = vec![1, 2, 3];         //                      +
    let r1;                         //                      |
    {                               //                      |
        let v2 = vec![4, 5, 6];     //                 +    |
        {                           //                 |    |
            let r2 = &v2;           //  +              |    |
            let v3 = vec![7,8,9];   //  |         +   'v2  'v1
            r1 = &v1;               // 'r2   +   'v3   |    |
            foo(r2);                //  |    |    |    |    |
        }                           //  +   'r1   +    |    |
    }                               //       |         +    |
    foo(r1);                        //       |              |
}                                   //       +              +
```

``` {.rust}
fn foo<'a>(v: &'a Vec<i32>) { println!("v[1]: {}", v[1]); }
```

borrow `&v2` is for at least `'r2`, but at most `'v2`

## Lexical Scopes, but Nontrivial { data-transition="slide-in fade-out" }

```rust
#[test]
fn copying_can_extend_a_borrows_lifetime() {
    fn foo<'a>(v: &'a Vec<i32>) {
        println!("v[1]: {}", v[1]);
    }
    let v1 = vec![1, 2, 3]; //         +
    let r2 = {              //         |
        let r1 = &v1;       //  +      |
        //       ^~~        //  |      |
        foo(r1);            // 'r1     |
        r1                  //  |     'v1
    };                      //  +  +   |
                            //     |   |
    foo(r2);                //    'r2  |
                            //     |   |
}                           //     +   +
```

``` {.rust}
fn foo<'a>(v: &'a Vec<i32>) { println!("v[1]: {}", v[1]); }
```

(How long does the borrow `&v1` last? Does `'r1` suffice?)

## Lexical Scopes, but Nontrivial { data-transition="fade-in" }

``` {.rust}
#[test]
fn copying_can_extend_a_borrows_lifetime() {
    fn foo<'a>(v: &'a Vec<i32>) {
        println!("v[1]: {}", v[1]);
    }
    let v1 = vec![1, 2, 3]; //         +
    let r2: &'y Vec<i32> = {//         |         'y >= 'r2
        let r1 = &'z v1;    //  +      |  'v1 >= 'z >= 'r1
        //       ^~~~~~     //  |      |
        foo(r1);//  |       // 'r1     |
        r1      // (caveat) //  |     'v1
    };                      //  +  +   |         'z == 'y
                            //     |   |
    foo(r2);                //    'r2  |
                            //     |   |
}                           //     +   +
```

``` {.rust}
fn foo<'a>(v: &'a Vec<i32>) { println!("v[1]: {}", v[1]); }
```

`'r1` too short! (caveat: above is not legal Rust)

-->
</section><section id="imm-borrows-can-be-copied-freely" class="slide level2" data-transition="slide-out">
<h1>imm-borrows: can be copied freely</h1>
<p>(super super useful to be able to share readable data!)</p>
</section><section id="imm-borrows-can-be-copied-freely-1" class="slide level2" data-transition="slide-in fade-out">
<h1>imm-borrows: can be copied freely</h1>
<p>Implications:</p>
<ul>
<li>must assume aliased (perhaps by another thread)</li>
<li>therefore <em>not safe</em> to mutate in general</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_cannot_mutate_imm_borrow() {
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    <span class="kw">let</span> b = &amp;v1;
    <span class="kw">let</span> (b1, b2, b3) = (b, b, b);
    try_modify(b);
    <span class="pp">println!</span>(<span class="st">&quot;v1: {:?}&quot;</span>, v1);
}

<span class="kw">fn</span> try_modify(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
    v.push(<span class="dv">4</span>);
}</code></pre></div>
<pre class="fragment compile_error"><code>error: cannot borrow immutable borrowed content `*v` as mutable
    v.push(4);
    ^</code></pre>
</section><section id="imm-borrows-can-be-copied-freely-2" class="slide level2" data-transition="fade-in slide-out">
<h1>imm-borrows: can be copied freely</h1>
<p>Implications:</p>
<ul>
<li>must assume aliased (perhaps by another thread)</li>
<li>therefore <em>not safe</em> to mutate in general</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_cannot_mutate_imm_borrow() {
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    <span class="kw">let</span> b = &amp;v1;
    <span class="kw">let</span> (b1, b2, b3) = (b, b, b);
    try_modify(b);
    <span class="pp">println!</span>(<span class="st">&quot;v1: {:?}&quot;</span>, v1);
}

<span class="kw">fn</span> try_modify(v: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
    v.push(<span class="dv">4</span>);
}</code></pre></div>
<pre><code>WHAT
      A
         BUMMER!!!</code></pre>
</section><section id="i-want-my-imperative-algorthms-..." class="slide level2">
<h1>&quot;... I want my imperative algorthms! ...&quot;</h1>
</section><section id="mut-borrows" class="slide level2">
<h1><code class="sourceCode rust">&amp;<span class="kw">mut</span></code> borrows</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_can_mutate_mut_borrow() {
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    modify(&amp;<span class="kw">mut</span> v1);
    <span class="pp">println!</span>(<span class="st">&quot;v1: {:?}&quot;</span>, v1);
}

<span class="kw">fn</span> modify(v: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
    v.push(<span class="dv">4</span>);
}</code></pre></div>
<pre class="fragment"><code>v1: [1, 2, 3, 4]</code></pre>
</section><section id="what-does-mut-mean-crucial" class="slide level2" data-transition="zoom-out">
<h1>What does <code class="sourceCode rust">&amp;<span class="kw">mut</span></code> mean (crucial)</h1>
<p><code class="sourceCode rust">&amp;<span class="kw">mut</span></code> is <em>not</em> about &quot;being the only way to mutate&quot;</p>
<ul>
<li>It is about <em>exclusive access</em></li>
</ul>
<p>An operation requiring exclusive access should either:</p>
<ul>
<li><p>take ownership, or,</p></li>
<li><p>take an <code class="sourceCode rust">&amp;<span class="kw">mut</span></code>-reference</p></li>
</ul>
</section><section id="mut-is-about-exclusive-access" class="slide level2" data-transition="zoom-in">
<h1><code class="sourceCode rust">&amp;<span class="kw">mut</span></code> is about exclusive access</h1>
<p>&quot;<code class="sourceCode rust"><span class="kw">mut</span></code> means 'mutate' ...&quot; is a fiction</p>
<div class="fragment">
<p>For many types, safe mutation <em>does</em> require exclusive access</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">vec.push(<span class="dv">4</span>);
<span class="co">// requires `vec: &amp;mut Vec&lt;_&gt;`, for safe manipulation of backing store</span></code></pre></div>
<p>&quot;<code class="sourceCode rust"><span class="kw">mut</span></code> means 'mutate' ...&quot; is a <em>convenient fiction</em></p>
</div>
<div class="fragment">
<p>(For related naming drama, do a search for: &quot;mutpocalypse&quot;)</p>
</div>
</section><section id="mut-safety-enforcement" class="slide level2">
<h1><code class="sourceCode rust">&amp;<span class="kw">mut</span></code> safety enforcement</h1>
</section><section id="data-has-at-most-one-mut-borrow" class="slide level2" data-transition="slide-in fade-out">
<h1>Data has at most one <code class="sourceCode rust">&amp;<span class="kw">mut</span></code> borrow</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> take2&lt;<span class="ot">&#39;a</span>&gt;(v1: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, v2: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_cannot_mut_borrow_multiple_times() {
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    <span class="kw">let</span> <span class="kw">mut</span> v2 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    take2(&amp;<span class="kw">mut</span> v1, &amp;<span class="kw">mut</span> v2); <span class="co">// &lt;-- this is okay</span>
    take2(&amp;<span class="kw">mut</span> v1, &amp;<span class="kw">mut</span> v1);
}</code></pre></div>
<pre class="fragment compile_error"><code>error: cannot borrow `v1` as mutable more than once at a time
    take2(&amp;mut v1, &amp;mut v1);
                        ^~
note: previous borrow of `v1` occurs here; the mutable borrow
      prevents subsequent moves, borrows, or modification of
      `v1` until the borrow ends
    take2(&amp;mut v1, &amp;mut v1);
               ^~

</code></pre>
</section><section id="cannot-alias-mut-borrowed-data" class="slide level2" data-transition="fade">
<h1>Cannot alias <code class="sourceCode rust">&amp;<span class="kw">mut</span></code>-borrowed data</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> take2&lt;<span class="ot">&#39;a</span>&gt;(v1: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, v2: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_cannot_alias_mut_borrowed_data() {
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    <span class="kw">let</span> <span class="kw">mut</span> v2 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    take2(&amp;<span class="kw">mut</span> v1, &amp;v2); <span class="co">// &lt;-- this is okay</span>
    take2(&amp;<span class="kw">mut</span> v1, &amp;v1);
}</code></pre></div>
<pre class="fragment compile_error"><code>error: cannot borrow `v1` as immutable because it is also borrowed
       as mutable
    take2(&amp;mut v1, &amp;v1);
                    ^~
note: previous borrow of `v1` occurs here; the mutable borrow 
      prevents subsequent moves, borrows, or modification of `v1`
      until the borrow ends
    take2(&amp;mut v1, &amp;v1);
               ^~</code></pre>
</section><section id="mut-t-is-non-copy" class="slide level2" data-transition="fade-in slide-out">
<h1><code class="sourceCode rust">&amp;<span class="kw">mut</span> T</code> is non-copy</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> take2&lt;<span class="ot">&#39;a</span>&gt;(v1: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;, v2: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_cannot_copy_mut_borrows() {
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    <span class="kw">let</span> b = &amp;<span class="kw">mut</span> v1;
    <span class="kw">let</span> c = b;
    take2(b, c);
}</code></pre></div>
<pre class="fragment compile_error"><code>error: use of moved value: `*b` [E0382]
    take2(b, c);
          ^
note: `b` moved here because it has type
      `&amp;mut collections::vec::Vec&lt;i32&gt;`, which is moved by default
    let c = b;
        ^</code></pre>
<p>(ensures exclusive access)</p>
</section><section id="exclusive-access-versus-ownership" class="slide level2">
<h1>Exclusive Access versus Ownership</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> take_by_value(v: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { <span class="kw">let</span> <span class="kw">mut</span> v = v; v.push(<span class="dv">4</span>);  }
<span class="kw">fn</span> take_mut_borrow(b: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) { b.push(<span class="dv">10</span>); }
<span class="co">// seemingly similar in power</span></code></pre></div>
<div class="fragment">
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_exclusive_access_versus_ownership() {
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    <span class="kw">let</span> <span class="kw">mut</span> v2 = <span class="pp">vec!</span>[<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>];
    take_by_value(v1);
    take_mut_borrow(&amp;<span class="kw">mut</span> v2);
    <span class="pp">println!</span>(<span class="st">&quot;v1: {:?} v2: {:?}&quot;</span>, v1, v2);
}</code></pre></div>
<pre class="fragment compile_error"><code>error: use of moved value: `v1` [E0382]
    println!(&quot;v1: {:?} v2: {:?}&quot;, v1, v2);
                                  ^~
note: `v1` moved here
    take_by_value(v1);
                  ^~</code></pre>
</div>
<div class="fragment">
<p>ownership ⇒ moves; power + responsibility for dropping</p>
</div>
</section></section>
<section><section id="exercises-2" class="titleslide slide level1"><h1>Exercises</h1></section><section id="exercises-2-1" class="slide level2">
<h1>Exercises 2</h1>
<p><a href="http://pnkfelix.github.io/cyot/tutorial/exercises/ex_part_2.html" class="uri">http://pnkfelix.github.io/cyot/tutorial/exercises/ex_part_2.html</a></p>
</section></section>
<section><section id="part-2-programming-in-the-large" class="titleslide slide level1"><h1>Part 2: Programming in the Large</h1></section><section id="everyones-installed-right" class="slide level2">
<h1>Everyone's installed (right?)</h1>
<p>What is local development like?</p>
<ul>
<li><p>rustc</p></li>
<li><p>cargo</p></li>
<li><p>modules and the filesystem</p></li>
<li><p>crates.io</p></li>
</ul>
</section><section id="rustc" class="slide level2">
<h1>rustc</h1>
<pre class="sh-session"><code>[bash]$ cat /tmp/hello.rs</code></pre>
<p><code class="filename">/tmp/hello.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() { <span class="pp">println!</span>(<span class="st">&quot;hello world&quot;</span>); }</code></pre></div>
<pre class="sh-session"><code>[bash]$ rustc /tmp/hello.rs -o /tmp/hello
[bash]$ /tmp/hello
hello world
[bash]$</code></pre>
</section><section id="getting-started-with-cargo" class="slide level2">
<h1>Getting started with cargo</h1>
<pre class="sh-session"><code>[bash]$ cargo new my-new-crate
[bash]$ cd my-new-crate
[bash]$ find * -type f
Cargo.toml
src/lib.rs
[bash]$ cat src/lib.rs</code></pre>
<p><code class="filename">src/lib.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> it_works() {
}</code></pre></div>
<pre class="sh-session"><code>[bash]$ cargo build
   Compiling my-new-crate v0.1.0 (file:///private/tmp/my-new-crate)
[bash]$ </code></pre>
</section><section class="slide level2">

<pre class="sh-session"><code>[bash]$ cargo test
   Compiling my-new-crate v0.1.0 (file:///private/tmp/my-new-crate)
     Running target/debug/my_new_crate-7ad82271427661a1

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests my-new-crate

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured

[bash]$ </code></pre>
</section><section class="slide level2">

<pre class="sh-session"><code>[bash]$ cd ..
[bash]$ cargo new --bin my-rust-program
[bash]$ cd my-rust-program
[bash]$ find * -type f
Cargo.toml
src/main.rs
[bash]$ cat src/main.rs</code></pre>
<p><code class="filename">src/main.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
    <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>);
}</code></pre></div>
<pre class="sh-session"><code>[bash]$ cargo run
   Compiling my-rust-program v0.1.0 (file:///private/tmp/my-rust-program)
     Running `target/debug/my-rust-program`
Hello, world!
[bash]$ </code></pre>
</section><section id="crates-versus-modules" class="slide level2">
<h1>crates versus modules</h1>
<ul>
<li><p>Crate: A unit of compilation</p></li>
<li><p>Module: A collection of items</p></li>
<li><p>Each crate is a tree of modules</p></li>
</ul>
<!--
## crates

  * A crate is a unit of compilation
  * Code can link to other previously compiled crates
  * `extern crate other_crate;`{.rust}
  * compiler finds it in file system, extracts names and types of its exports
  * Makes `other_crate` available as a name to reference

## modules

  * Module is a collection of items
  * Purpose: namespacing and encapsulation
  * Note: a submodule is a kind of item.
    * i.e. modules form a hierarchy
  * Modules can have cyclic references, *within* a single crate
-->
</section><section id="mod-tree-hierarchy" class="slide level2">
<h1><code class="sourceCode rust"><span class="kw">mod</span></code> tree hierarchy</h1>
<p><code class="filename">src/lib.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> a {
    <span class="kw">mod</span> b { <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>; }
    <span class="kw">mod</span> c {

        <span class="kw">pub</span> <span class="kw">fn</span> add3(x: <span class="kw">super</span>::b::I) -&gt; <span class="kw">super</span>::b::I { x + <span class="dv">3</span> }
    }
}</code></pre></div>
<div class="fragment">
<p>(whoa, all those <code class="sourceCode rust"><span class="kw">super</span>::b::I</code> paths are ugly)</p>
</div>
</section><section id="can-use-any-kind-of-item" class="slide level2">
<h1>can <code class="sourceCode rust"><span class="kw">use</span></code> any kind of item</h1>
<p><code class="filename">src/lib.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> a {
    <span class="kw">mod</span> b { <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>; }
    <span class="kw">mod</span> c {
        <span class="kw">use</span> a::b;
        <span class="kw">pub</span> <span class="kw">fn</span> add3(x: b::I) -&gt; b::I { x + <span class="dv">3</span> }
    }
}</code></pre></div>
<div class="fragment">
<h4 id="or-even-rename">or even rename</h4>
<p><code class="filename">src/lib.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> a {
    <span class="kw">mod</span> b { <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>; }
    <span class="kw">mod</span> c {
        <span class="kw">use</span> a::b::I <span class="kw">as</span> J;
        <span class="kw">pub</span> <span class="kw">fn</span> add3(x: J) -&gt; J { x + <span class="dv">3</span> }
    }
}</code></pre></div>
<p>(consult your local style guidelines)</p>
</div>
</section><section id="mod-hierarchy-and-file-system" class="slide level2" data-transition="fade-out">
<h1><code class="sourceCode rust"><span class="kw">mod</span></code> hierarchy and file system</h1>
<p>Everything can be inline:</p>
<p><code class="filename">src/lib.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> a {
    <span class="kw">mod</span> b { <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>; }
    <span class="kw">mod</span> c {
        <span class="kw">use</span> a::b::I;
        <span class="kw">pub</span> <span class="kw">fn</span> add3(x: I) -&gt; I { x + <span class="dv">3</span> }
    }
}</code></pre></div>
</section><section id="mod-hierarchy-and-file-system-1" class="slide level2" data-transition="fade-in">
<h1><code class="sourceCode rust"><span class="kw">mod</span></code> hierarchy and file system</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> a {
    <span class="kw">mod</span> b { <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>; }
    <span class="kw">mod</span> c {
        <span class="kw">use</span> a::b::I;
        <span class="kw">pub</span> <span class="kw">fn</span> add3(x: I) -&gt; I { x + <span class="dv">3</span> }
    }
}</code></pre></div>
<div class="fragment">
<p>Shorthand: '<code class="sourceCode rust"><span class="kw">mod</span> name;</code>' with subfiles at proper paths</p>
</div>
<div class="fragment">
<p><code class="filename">src/lib.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> a {
    <span class="kw">mod</span> b { <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>; }
    <span class="kw">mod</span> c;
}</code></pre></div>
<!-- Above block is why there is `a/c.rs` file floating around;
     It is keeping us honest. :)
-->
<p><code class="filename">src/a/c.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">        <span class="kw">use</span> a::b::I;
        <span class="kw">pub</span> <span class="kw">fn</span> add3(x: I) -&gt; I { x + <span class="dv">3</span> }</code></pre></div>
<p>(Obviously do not indent your code this way.)</p>
</div>
</section><section id="mod-foo-versus-use-foo" class="slide level2">
<h1><code>mod foo;</code> versus <code>use foo;</code></h1>
<ul>
<li><p>The syntax <code class="sourceCode rust"><span class="kw">mod</span> foo;</code> is <em>just</em> sugar for</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> foo {
  &lt;&lt; insert contents of foo.rs here &gt;&gt;
}</code></pre></div></li>
<li><p>The <code class="sourceCode rust"><span class="kw">mod</span></code>-syntax <em>creates</em> definitions</p></li>
<li><p>The <code class="sourceCode rust"><span class="kw">use</span></code>-syntax imports bindings into namespace</p></li>
</ul>
<div class="fragment">
<ul>
<li>Beginners often erroneosuly write <code>mod foo;</code> when they meant <code>use foo;</code></li>
</ul>
<!--
  * Why confusing, sometimes even to Rust experts??

    ``` {.rust .fragment}
    use foo; // (this is legal, depending on what `foo` is.)
    ```
-->
<!--
```rust
mod c {
    use demo_foo_from_lib_at_root;
}
```
-->
</div>
</section><section id="pub-privacy" class="slide level2">
<h1><code class="sourceCode rust"><span class="kw">pub</span></code> (privacy)</h1>
</section><section id="items-are-private-by-default" class="slide level2">
<h1>items are private by default</h1>
<h4 id="usually">(usually)</h4>
</section><section id="using-pub-items" class="slide level2" data-transition="fade-out">
<h1>using pub items</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> d {
    <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>;
    <span class="kw">pub</span> <span class="kw">fn</span> add3(x: I) -&gt; I { add3priv(x) }
    <span class="kw">fn</span> add3priv(x: I) -&gt; I { x + <span class="dv">3</span> }
}</code></pre></div>
<!-- -->
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> e {
    <span class="kw">use</span> <span class="kw">super</span>::d::add3;
    <span class="at">#[</span>test<span class="at">]</span> <span class="kw">fn</span> t() { <span class="pp">assert_eq!</span>(add3(<span class="dv">1</span>), <span class="dv">4</span>); }
}</code></pre></div>
<p>(this works)</p>
</section><section id="privacy" class="slide level2" data-transition="fade-in">
<h1>privacy</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> d {
    <span class="kw">pub</span> <span class="kw">type</span> I = <span class="dt">i32</span>;
    <span class="kw">pub</span> <span class="kw">fn</span> add3(x: I) -&gt; I { add3priv(x) }
    <span class="kw">fn</span> add3priv(x: I) -&gt; I { x + <span class="dv">3</span> }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="kw">mod</span> f {
    <span class="kw">use</span> <span class="kw">super</span>::d::add3priv;
    <span class="at">#[</span>test<span class="at">]</span> <span class="kw">fn</span> t() { <span class="pp">assert_eq!</span>(add3priv(<span class="dv">1</span>), <span class="dv">4</span>); }
}</code></pre></div>
<pre class="shell-session"><code>error: function `add3priv` is private
    use super::d::add3priv;
        ^~~~~~~~~~~~~~~~~~</code></pre>
</section><section id="crates.io" class="slide level2 left_align">
<h1>crates.io</h1>
<div class="fragment">
<ul>
<li><p>Cargo's main feature: dependency management</p></li>
<li><p>Before hacking something up, check <a href="http://crates.io/">crates.io</a> first</p></li>
<li><p>Adding a third-party crate like <code>quickcheck</code> is as simple as adding this to the <code>Cargo.toml</code></p></li>
</ul>
<p><code class="filename">Cargo.toml</code></p>
<div class="sourceCode"><pre class="sourceCode ini"><code class="sourceCode ini"><span class="kw">[dependencies]</span>
<span class="dt">quickcheck </span><span class="ot">=</span><span class="st"> &quot;</span><span class="fl">0.2.20</span><span class="st">&quot;</span></code></pre></div>
</div>
<div class="fragment">
<p>Then add this:</p>
<p><code class="filename">lib.rs</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> quickcheck;</code></pre></div>
<p>to your <code>lib.rs</code>, and you have access to quickcheck!</p>
<!--
## Diamonds

`add3/src/lib.rs (v1.0.0)`{.filename}
``` {.rust}
pub fn add3(x: i32) -> i32 { x + 3 }
```

`add3/src/lib.rs (v2.0.0)`{.filename}
``` {.rust}
pub fn add3(x: i64) -> i64 { x + 3 }
```

`add6/Cargo.toml`{.filename}
```INI
[dependencies]
add3 = "1.0.0"
```

`add6_64/Cargo.toml`{.filename}
```INI
[dependencies]
add3 = "2.0.0"
```

`diamond/Cargo.toml`{.filename}
```INI
[dependencies.add6_64]
path = "/Users/fklock/Dev/Rust/add6_64/"

[dependencies.add6]
path = "/Users/fklock/Dev/Rust/add6/"
```
-->
</div>
</section></section>
<section><section id="part-3-sequence-types-and-iteration" class="titleslide slide level1"><h1>Part 3: Sequence Types and Iteration</h1></section><section id="vectors-and-arrays" class="slide level2" data-transition="fade-out">
<h1>Vectors and Arrays</h1>
<p>Array <code>[T; k]</code> vs vector <code>Vec&lt;T&gt;</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_vec_and_array() {
    <span class="co">// Heap-allocated vector</span>
    <span class="kw">let</span> vec: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt; = <span class="pp">vec!</span>[<span class="dv">1000</span>, <span class="dv">200</span>, <span class="dv">32</span>, <span class="dv">4</span>];
    <span class="co">// Stack-allocated array</span>
    <span class="kw">let</span> array: [<span class="dt">i32</span>; <span class="dv">4</span>] = [<span class="dv">2000</span>, <span class="dv">400</span>, <span class="dv">32</span>, <span class="dv">4</span>];








}</code></pre></div>
</section><section id="iteration-over-ranges" class="slide level2" data-transition="fade">
<h1>Iteration over ranges</h1>
<p>Range constructor: <code>start..limit</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_range() {

    <span class="kw">let</span> vec: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt; = <span class="pp">vec!</span>[<span class="dv">1000</span>, <span class="dv">200</span>, <span class="dv">32</span>, <span class="dv">4</span>];

    <span class="kw">let</span> array: [<span class="dt">i32</span>; <span class="dv">4</span>] = [<span class="dv">2000</span>, <span class="dv">400</span>, <span class="dv">32</span>, <span class="dv">4</span>];

    <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">2</span> {
        <span class="co">//   ~~~~ range from 0 (inclusive) to 2 (exclusive)</span>
        <span class="pp">assert_eq!</span>(vec[i] * <span class="dv">2</span>, array[i]);
    }
    <span class="kw">for</span> i <span class="kw">in</span> <span class="dv">2.</span>.<span class="dv">4</span> {
        <span class="pp">assert_eq!</span>(vec[i], array[i]);
    }
}</code></pre></div>
</section><section id="vectors-and-arrays-and-slices" class="slide level2" data-transition="fade-in">
<h1>Vectors and Arrays and Slices</h1>
<p>Shared slice of a sequence: <code>[T]</code> (cannot be stored on stack)</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_slice() {

    <span class="kw">let</span> vec: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt; = <span class="pp">vec!</span>[<span class="dv">1000</span>, <span class="dv">200</span>, <span class="dv">32</span>, <span class="dv">4</span>];

    <span class="kw">let</span> array: [<span class="dt">i32</span>; <span class="dv">4</span>] = [<span class="dv">2000</span>, <span class="dv">400</span>, <span class="dv">32</span>, <span class="dv">4</span>];



    <span class="kw">let</span> slice_1: &amp;[<span class="dt">i32</span>] = &amp;vec[<span class="dv">2.</span>.<span class="dv">4</span>];
    <span class="kw">let</span> slice_2: &amp;[<span class="dt">i32</span>] = &amp;array[<span class="dv">2.</span>.<span class="dv">4</span>];
    <span class="pp">assert_eq!</span>(slice_1, slice_2);

    <span class="pp">assert_eq!</span>(slice_1[<span class="dv">0</span>], slice_1[<span class="dv">1</span>] * <span class="dv">8</span>);
}</code></pre></div>
</section><section id="for-and-iterators" class="slide level2" data-transition="fade-out">
<h1><code>for</code> and iterators</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span> <span class="kw">fn</span> demo_iters_1() {
    <span class="kw">let</span> zvecs = <span class="pp">vec!</span>[<span class="pp">vec!</span>[<span class="dv">0</span>,<span class="dv">0</span>], <span class="pp">vec!</span>[<span class="dv">0</span>,<span class="dv">0</span>], <span class="pp">vec!</span>[<span class="dv">0</span>,<span class="dv">0</span>], <span class="pp">vec!</span>[<span class="dv">0</span>,<span class="dv">0</span>]];

    <span class="co">// Every `for` loop takes an iterator.</span>

    <span class="co">// Some iterators are made by *consuming* input:</span>
    <span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1000</span>, <span class="dv">1001</span>, <span class="dv">1002</span>, <span class="dv">1003</span>];
    <span class="kw">for</span> i <span class="kw">in</span> <span class="pp">vec!</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] {
        <span class="pp">assert_eq!</span>(v[i], <span class="dv">1000</span> + i);
    }

    <span class="co">// Some iterators are made by *borrowing* input:</span>
    <span class="kw">for</span> elem <span class="kw">in</span> &amp;zvecs {
        <span class="kw">let</span> elem: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt; = elem;     <span class="co">// &lt;-- errors here</span>
        <span class="pp">assert_eq!</span>(elem, <span class="pp">vec!</span>[<span class="dv">0</span>,<span class="dv">0</span>]);   <span class="co">// &lt;--- and here</span>
    }
}</code></pre></div>
</section><section id="for-and-iterators-1" class="slide level2" data-transition="fade-in">
<h1><code>for</code> and iterators</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span> <span class="kw">fn</span> demo_iters_2() {
    <span class="kw">let</span> zvecs = <span class="pp">vec!</span>[<span class="pp">vec!</span>[<span class="dv">0</span>,<span class="dv">0</span>], <span class="pp">vec!</span>[<span class="dv">0</span>,<span class="dv">0</span>], <span class="pp">vec!</span>[<span class="dv">0</span>,<span class="dv">0</span>], <span class="pp">vec!</span>[<span class="dv">0</span>,<span class="dv">0</span>]];

    <span class="co">// Every `for` loop takes an iterator.</span>

    <span class="co">// Some iterators are made by *consuming* input:</span>
    <span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1000</span>, <span class="dv">1001</span>, <span class="dv">1002</span>, <span class="dv">1003</span>];
    <span class="kw">for</span> i <span class="kw">in</span> <span class="pp">vec!</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] {
        <span class="pp">assert_eq!</span>(v[i], <span class="dv">1000</span> + i);
    }

    <span class="co">// Some iterators are made by *borrowing* input:</span>
    <span class="kw">for</span> elem <span class="kw">in</span> &amp;zvecs {
        <span class="kw">let</span> elem: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt; = elem;    <span class="co">// &lt;-- this is (one)</span>
        <span class="pp">assert_eq!</span>(elem, &amp;<span class="pp">vec!</span>[<span class="dv">0</span>,<span class="dv">0</span>]); <span class="co">// &lt;--- way to fix</span>
    }
}</code></pre></div>
</section><section id="string-and-str" class="slide level2">
<h1><code>String</code> and <code>&amp;str</code></h1>
<ul>
<li><p><code>String</code> and <code>Vec&lt;T&gt;</code>: owned, growable</p></li>
<li><p><code>str</code> and <code>[T]</code>: fixed-size, cannot be stored on stack</p></li>
<li><p>Both <code>String</code> and <code>str</code> are UTF-8 (a safety guarantee)</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_string_and_str() {
    <span class="kw">let</span> <span class="kw">mut</span> hw: <span class="dt">String</span> = <span class="dt">String</span>::new();
    hw.push_str(<span class="st">&quot;Hello&quot;</span>);
    hw.push_str(<span class="st">&quot; &quot;</span>);
    hw.push_str(<span class="st">&quot;World!&quot;</span>);
    <span class="pp">assert_eq!</span>(hw, <span class="st">&quot;Hello World!&quot;</span>);

    <span class="kw">let</span> h: &amp;<span class="dt">str</span> = &amp;hw[<span class="dv">0.</span>.<span class="dv">5</span>];
    <span class="kw">let</span> w: &amp;<span class="dt">str</span> = &amp;hw[<span class="dv">6.</span>.<span class="dv">11</span>];

    <span class="pp">assert_eq!</span>(h, <span class="st">&quot;Hello&quot;</span>);
    <span class="pp">assert_eq!</span>(w, <span class="st">&quot;World&quot;</span>);
}</code></pre></div>
</section><section id="iterator-api" class="slide level2" data-transition="fade-out">
<h1>Iterator API</h1>
<p>Every iterator inherits many <a href="https://doc.rust-lang.org/nightly/std/iter/index.html">high-level methods</a></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_iter_methods_1() {
    <span class="kw">let</span> v1: <span class="dt">Vec</span>&lt;&amp;<span class="dt">str</span>&gt; = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;to&quot;</span>, <span class="st">&quot;all&quot;</span>, <span class="st">&quot;da&quot;</span>, <span class="st">&quot;World!&quot;</span>];
    <span class="kw">let</span> v2: <span class="dt">Vec</span>&lt;&amp;<span class="dt">str</span>&gt; = v1.iter()    <span class="co">// borrowing iterator for vec</span>
        .filter(|w| { w.len() &gt; <span class="dv">3</span> }) <span class="co">// del entries of length &lt;= 3 </span>
        .map(|p| -&gt; &amp;<span class="dt">str</span> { *p })     <span class="co">// deref each by one level</span>
        .collect();                  <span class="co">// collect into target vec</span>
    <span class="pp">println!</span>(<span class="st">&quot; v1: {:?} </span><span class="sc">\n</span><span class="st"> v2: {:?}&quot;</span>, v1, v2);
}</code></pre></div>
<h4 id="prints" class="fragment" data-fragment-index="1">prints</h4>
<pre class="fragment" data-fragment-index="1"><code> v1: [&quot;Hello&quot;, &quot;to&quot;, &quot;all&quot;, &quot;da&quot;, &quot;World!&quot;]
 v2: [&quot;Hello&quot;, &quot;World!&quot;]

</code></pre>
</section><section id="iterator-api-1" class="slide level2" data-transition="fade">
<h1>Iterator API</h1>
<p>There is some cool type-based magic</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_iter_methods_2() {
    <span class="kw">let</span> v1: <span class="dt">Vec</span>&lt;&amp;<span class="dt">str</span>&gt; = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;to&quot;</span>, <span class="st">&quot;all&quot;</span>, <span class="st">&quot;da&quot;</span>, <span class="st">&quot;World!&quot;</span>];
    <span class="kw">let</span> s2: <span class="dt">String</span>    = v1.iter()    <span class="co">// borrowing iterator for vec</span>
        .filter(|w| { w.len() &gt; <span class="dv">3</span> }) <span class="co">// del entries of length &lt;= 3 </span>
        .map(|p| -&gt; &amp;<span class="dt">str</span> { *p })     <span class="co">// deref each by one level</span>
        .collect();                  <span class="co">// collect into target string</span>
    <span class="pp">println!</span>(<span class="st">&quot; v1: {:?} </span><span class="sc">\n</span><span class="st"> s2: {:?}&quot;</span>, v1, s2);
}</code></pre></div>
<h4 id="prints-1" class="fragment" data-fragment-index="1">prints</h4>
<pre class="fragment" data-fragment-index="1"><code> v1: [&quot;Hello&quot;, &quot;to&quot;, &quot;all&quot;, &quot;da&quot;, &quot;World!&quot;] 
 s2: &quot;HelloWorld!&quot;

</code></pre>
</section><section id="iterator-api-2" class="slide level2" data-transition="fade">
<h1>Iterator API</h1>
<p>All magic needs ingredients to work:</p>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_iter_methods_3() {
    <span class="kw">let</span> v1            = <span class="pp">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;to&quot;</span>, <span class="st">&quot;all&quot;</span>, <span class="st">&quot;da&quot;</span>, <span class="st">&quot;World!&quot;</span>];
    <span class="kw">let</span> x2            = v1.iter()    <span class="co">// borrowing iterator for vec</span>
        .filter(|w| { w.len() &gt; <span class="dv">3</span> }) <span class="co">// del entries of length &lt;= 3 </span>
        .map(|p| -&gt; &amp;<span class="dt">str</span> { *p })     <span class="co">// deref each by one level</span>
        .collect();                  <span class="co">// collect into target ?????</span>
    <span class="pp">println!</span>(<span class="st">&quot; v1: {:?} </span><span class="sc">\n</span><span class="st"> x2: {:?}&quot;</span>, v1, x2);
}</code></pre></div>
<h4 id="error" class="fragment" data-fragment-index="1">error</h4>
<pre class="fragment" data-fragment-index="1"><code>error: unable to infer enough type information about `_`; 
       type annotations or generic parameter binding required
    let x2 = v1.iter()
        ^~</code></pre>
</section></section>
<section><section id="exercises-3" class="titleslide slide level1"><h1>Exercises</h1></section><section id="exercises-3-1" class="slide level2">
<h1>Exercises 3</h1>
<p><a href="http://pnkfelix.github.io/cyot/tutorial/exercises/ex_part_3.html" class="uri">http://pnkfelix.github.io/cyot/tutorial/exercises/ex_part_3.html</a></p>
</section></section>
<section><section id="part-4-back-to-language-fundamentals" class="titleslide slide level1"><h1>Part 4: Back to Language Fundamentals</h1></section><section id="structs" class="slide level2">
<h1>structs</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Copy</span><span class="at">,</span> <span class="bu">Clone</span><span class="at">)]</span>
<span class="kw">struct</span> Point { <span class="kw">pub</span> x: <span class="dt">i32</span>, <span class="kw">pub</span> y: <span class="dt">i32</span> }

<span class="kw">fn</span> proj_x_axis(p: &amp;Point) -&gt; Point {
    Point { x: p.x, y: <span class="dv">0</span> }
}

<span class="kw">fn</span> nudge_left(p: &amp;<span class="kw">mut</span> Point) { p.x -= <span class="dv">10</span>; }</code></pre></div>
<p>Or add a method:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Point {
    <span class="kw">fn</span> proj_x_axis(&amp;<span class="kw">self</span>) -&gt; Point {
        Point { x: <span class="kw">self</span>.x, y: <span class="dv">0</span> }
    }
}</code></pre></div>
</section><section id="tuple-structs-generics" class="slide level2">
<h1>tuple-structs, generics</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Copy</span><span class="at">,</span> <span class="bu">Clone</span><span class="at">)]</span>
<span class="kw">struct</span> Angle(<span class="kw">pub</span> <span class="dt">f64</span>);   <span class="co">// construct with e.g. `Angle(90.0)`</span>

<span class="kw">struct</span> Pair&lt;X,Y&gt;(X, Y);  <span class="co">// now `Pair(1,2)` or `Pair(&quot;a&quot;,&quot;b&quot;)` work</span></code></pre></div>
<!--

```{.rust}
fn proj_x_axis(p: &Point) -> Point {
    Point { x: p.x, y: 0 }
}
```

```{.rust}
fn proj_x_axis(p: &Point) -> Point {
    Point { y: 0, ..p }
}
```
-->
<!--
```{.rust}
fn proj_x_axis_check(p: &Point) -> Point {
    Point { y: 0, ..p }
}
```
-->
</section><section id="enums" class="slide level2">
<h1>enums</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Line {
    Segment { start: Point, end: Point },
    Vector(Point, Angle),
}</code></pre></div>
<p>Pattern-matching:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> start(l: &amp;Line) -&gt; Point {
    <span class="kw">match</span> *l {
        Line::Vector(s, _) =&gt; s,
        Line::Segment { start: s, .. } =&gt; s,
    }
}</code></pre></div>
</section><section id="pattern-matching" class="slide level2">
<h1>Pattern-matching</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> start(l: &amp;Line) -&gt; Point {
    <span class="kw">match</span> *l {
        Line::Vector(s, _) =&gt; s,
        Line::Segment { start: s, .. } =&gt; s,
    }
}</code></pre></div>
<p>Richer than C-style <code>switch</code>:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">match</span> *l { <span class="co">// (not doing anything meaningful)</span>
        Line::Vector(Point { x: <span class="dv">0</span>, y }, _) =&gt; y,
        Line::Segment { start: Point { x, y: <span class="dv">0</span> }, .. } =&gt; x,
        _ =&gt; <span class="cn">false</span>,
    }</code></pre></div>
</section><section id="option-and-result" class="slide level2">
<h1>Option and Result</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="dt">Option</span>&lt;T&gt; { <span class="cn">Some</span>(T), <span class="cn">None</span> }

<span class="kw">enum</span> <span class="dt">Result</span>&lt;T, E&gt; { <span class="cn">Ok</span>(T), <span class="cn">Err</span>(E) }

<span class="co">// impl&lt;T, E&gt; Result&lt;T, E&gt; { pub fn ok(self) -&gt; Option&lt;T&gt; { ... } }</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::num::ParseIntError;
<span class="kw">fn</span> read_u32(s: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Result</span>&lt;<span class="dt">u32</span>, ParseIntError&gt; {
    s.parse()
}

<span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo() {
    <span class="pp">assert_eq!</span>(read_u32(<span class="st">&quot;4&quot;</span>), <span class="cn">Ok</span>(<span class="dv">4</span>));
    <span class="pp">assert!</span>(read_u32(<span class="st">&quot;4_no_no&quot;</span>).is_err());

    <span class="pp">assert_eq!</span>(read_u32(<span class="st">&quot;4&quot;</span>).ok(), <span class="cn">Some</span>(<span class="dv">4</span>));
}</code></pre></div>
</section><section id="lifetime-bindings-1" class="slide level2">
<h1>Lifetime Bindings 1</h1>
<p>We saw this kind of thing before:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> explicit_lifetime_binding_1() {
    <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>&gt;(ints: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ints[<span class="dv">1</span>]);
    }
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
    print(&amp;v1)
}</code></pre></div>
</section><section id="lifetime-bindings-2" class="slide level2" data-transition="fade-out">
<h1>Lifetime Bindings 2</h1>
<p>You can bind distinct lifetimes:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> explicit_lifetime_binding_2() {
    <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);

    }
    <span class="kw">let</span> one = <span class="dv">1</span>;
    <span class="kw">let</span> two = <span class="dv">2</span>;
    <span class="kw">let</span> three = <span class="dv">3</span>;
    <span class="kw">let</span> four = <span class="dv">4</span>;
    <span class="kw">let</span> v1 = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    print(&amp;v1)
}</code></pre></div>
</section><section id="lifetime-bindings-3" class="slide level2" data-transition="fade">
<h1>Lifetime Bindings 3</h1>
<p>Encode constraints by reusing same lifetime:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> explicit_lifetime_binding_3() {
    <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);
        ptrs.push(ptr);
    }
    <span class="kw">let</span> one = <span class="dv">1</span>;
    <span class="kw">let</span> two = <span class="dv">2</span>;
    <span class="kw">let</span> three = <span class="dv">3</span>;
    <span class="kw">let</span> four = <span class="dv">4</span>;
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    print(&amp;<span class="kw">mut</span> v1, &amp;four);
}</code></pre></div>
</section><section id="lifetime-bindings-4" class="slide level2" data-transition="fade-in">
<h1>Lifetime Bindings 4</h1>
<p>Encode constraints by reusing same lifetime:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> explicit_lifetime_binding_4() {
    <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);<span class="co">//~~~            ~~~</span>
        ptrs.push(ptr);            <span class="co">//   |              |</span>
    }                              <span class="co">// this must match that,</span>
    <span class="kw">let</span> one = <span class="dv">1</span>;                   <span class="co">// otherwise push is bogus</span>
    <span class="kw">let</span> two = <span class="dv">2</span>;
    <span class="kw">let</span> three = <span class="dv">3</span>;
    <span class="kw">let</span> four = <span class="dv">4</span>;
    <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    print(&amp;<span class="kw">mut</span> v1, &amp;four);
}</code></pre></div>
</section><section id="lifetime-bindings-5" class="slide level2" data-transition="fade-in">
<h1>Lifetime Bindings 5</h1>
<p>Compiler catches missing necessary constraints:</p>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> explicit_lifetime_binding_5() {
    <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>, <span class="ot">&#39;c</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;c</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);  <span class="co">//  ~~~            ~~~</span>
        ptrs.push(ptr);                <span class="co">//   |              |</span>
    }                                  <span class="co">// this must match that,</span>
    <span class="kw">let</span> one = <span class="dv">1</span>;                       <span class="co">// otherwise push is bogus</span>
}</code></pre></div>
<pre class="fragment"><code>error: cannot infer an appropriate lifetime for automatic coercion
       due to conflicting requirements
        ptrs.push(ptr);
                  ^~~
help: consider using an explicit lifetime parameter as shown:
    fn print&lt;&#39;a, &#39;b&gt;(ptrs: &amp;&#39;a mut Vec&lt;&amp;&#39;b i32&gt;, ptr: &amp;&#39;b i32)</code></pre>
</section><section id="borrowed-return-values-1" class="slide level2" data-transition="fade-out">
<h1>Borrowed return values 1</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> first_n_last&lt;<span class="ot">&#39;a</span>&gt;(ints: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; (&amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>, &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>) {
    <span class="co">//                                      ~~~~~~~  ~~~~~~~</span>
    (&amp;ints[<span class="dv">0</span>], &amp;ints[ints.len() - <span class="dv">1</span>])
}</code></pre></div>
<!--
TODO: Exercise idea: Try to write `fn first_and_last_mut`. Why is it impossible
in general?
-->
<div class="fragment">
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_borrowed_return_values() {
    <span class="kw">let</span> v = <span class="pp">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>];
    <span class="kw">let</span> (first, fourth) = first_n_last(&amp;v);
    <span class="pp">assert_eq!</span>(*first, <span class="dv">1</span>);
    <span class="pp">assert_eq!</span>(*fourth, <span class="dv">4</span>);
}</code></pre></div>
<p>(compiler ensures borrow <code class="sourceCode rust">&amp;v</code> lasts long enough to satisfy reads of <code>first</code> and <code>fourth</code>)</p>
</div>
</section><section id="borrowed-return-values-2" class="slide level2" data-transition="fade-in">
<h1>Borrowed return values 2</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="kw">fn</span> first_n_last&lt;<span class="ot">&#39;a</span>&gt;(ints: <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) -&gt; (&amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>, &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>) {
    <span class="co">//                    ~~~~~~~~ (hint)</span>
    (&amp;ints[<span class="dv">0</span>], &amp;ints[ints.len() - <span class="dv">1</span>])
}</code></pre></div>
<p>Why doesn't this work?</p>
<pre class="fragment" data-fragment-index="1"><code>error: `ints` does not live long enough
    (&amp;ints[0], &amp;ints[ints.len() - 1])
      ^~~~
note: reference must be valid for the lifetime &#39;a ...
note: ...but borrowed value is only valid for the scope of
note:    parameters for function</code></pre>
<div class="fragment">
<p>caller chooses <code class="sourceCode rust"><span class="ot">&#39;a</span></code>; <code>fn</code> body must work for any such choice</p>
<p>(Parameters dropped at scope end; won't live long enough)</p>
</div>
</section><section id="lifetime-elision" class="slide level2">
<h1>Lifetime Elision</h1>
</section><section id="all-the-a-b-...-are-ugly" class="slide level2">
<h1>All the <code class="sourceCode rust"><span class="ot">&#39;a</span></code>, <code class="sourceCode rust"><span class="ot">&#39;b</span></code>, ... are ugly</h1>
</section><section id="lifetime-elision-1" class="slide level2" data-transition="fade-out">
<h1>Lifetime Elision 1</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> lifetime_elision_1() {
    <span class="kw">fn</span> print1&lt;<span class="ot">&#39;a</span>&gt;(ints: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ints[<span class="dv">1</span>]);
    }
    <span class="kw">fn</span> print2&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);

    }
    <span class="kw">fn</span> print3&lt;<span class="ot">&#39;a</span>, <span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);
        ptrs.push(ptr);
    }
}</code></pre></div>
</section><section id="lifetime-elision-2" class="slide level2" data-transition="fade">
<h1>Lifetime Elision 2</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> lifetime_elision_2() {
    <span class="kw">fn</span> print1    (ints: &amp;   <span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ints[<span class="dv">1</span>]);
    }
    <span class="kw">fn</span> print2        (ptrs: &amp;   <span class="dt">Vec</span>&lt;&amp;   <span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);

    }
    <span class="kw">fn</span> print3&lt;    <span class="ot">&#39;b</span>&gt;(ptrs: &amp;   <span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);
        ptrs.push(ptr);
    }
}</code></pre></div>
</section><section id="lifetime-elision-3" class="slide level2" data-transition="fade-in">
<h1>Lifetime Elision 3</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> lifetime_elision_3() {
    <span class="kw">fn</span> print1(ints: &amp;<span class="dt">Vec</span>&lt;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ints[<span class="dv">1</span>]);
    }
    <span class="kw">fn</span> print2(ptrs: &amp;<span class="dt">Vec</span>&lt;&amp;<span class="dt">i32</span>&gt;) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);

    }
    <span class="kw">fn</span> print3&lt;<span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);
        ptrs.push(ptr);
    }
}</code></pre></div>
</section><section id="generic-items" class="slide level2">
<h1>Generic items</h1>
</section><section id="generic-items-1" class="slide level2" data-transition="fade-out">
<h1>Generic items 1</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> generic_items_1() {
    <span class="kw">fn</span> push_twice&lt;<span class="ot">&#39;b</span>&gt;(ptrs: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>&gt;, ptr: &amp;<span class="ot">&#39;b</span> <span class="dt">i32</span>) {
        ptrs.push(ptr);
        ptrs.push(ptr);
    }
    <span class="kw">let</span> (one, two, three, four) = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>);
    <span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    push_twice(&amp;<span class="kw">mut</span> v, &amp;four);
}</code></pre></div>
<p>This obviously generalizes beyond <code>i32</code>!</p>
</section><section id="generic-items-2" class="slide level2" data-transition="fade-in">
<h1>Generic items 2</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> generic_items_2() {
    <span class="kw">fn</span> push_twice&lt;<span class="ot">&#39;b</span>, T&gt;(ptrs: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> T&gt;, ptr: &amp;<span class="ot">&#39;b</span> T) {
        ptrs.push(ptr);
        ptrs.push(ptr);
    }
    <span class="kw">let</span> (one, two, three, four) = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>);
    <span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    push_twice(&amp;<span class="kw">mut</span> v, &amp;four);
}</code></pre></div>
<p>This is going so smoothly; lets try printing <code>v_1</code> again!</p>
</section><section id="generic-items-3" class="slide level2">
<h1>Generic items 3</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> generic_items_3() {
    <span class="kw">fn</span> push_twice&lt;<span class="ot">&#39;b</span>, T&gt;(ptrs: &amp;<span class="kw">mut</span> <span class="dt">Vec</span>&lt;&amp;<span class="ot">&#39;b</span> T&gt;, ptr: &amp;<span class="ot">&#39;b</span> T) {
        <span class="pp">println!</span>(<span class="st">&quot;v_1: {}&quot;</span>, ptrs[<span class="dv">1</span>]);
        ptrs.push(ptr);
        ptrs.push(ptr);
    }
    <span class="kw">let</span> (one, two, three, four) = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>);
    <span class="kw">let</span> <span class="kw">mut</span> v = <span class="pp">vec!</span>[&amp;one, &amp;two, &amp;three];
    push_twice(&amp;<span class="kw">mut</span> v, &amp;four);
}</code></pre></div>
<pre class="fragment"><code>error: trait `core::fmt::Display` not implemented for the type `T`
        println!(&quot;v_1: {}&quot;, ptrs[1]);
                            ^~~~~~~</code></pre>
<p>(Reminder: Rust is not C++)</p>
</section><section id="trait-bounded-polymorphism" class="slide level2">
<h1>Trait-bounded polymorphism</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Dimensioned {
    <span class="kw">fn</span> height(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span>;
    <span class="kw">fn</span> width(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span>;
}

<span class="kw">fn</span> stacked_height&lt;S&gt;(v: &amp;[S]) -&gt; <span class="dt">u32</span> <span class="kw">where</span> S: Dimensioned {
    <span class="kw">let</span> <span class="kw">mut</span> accum = <span class="dv">0</span>;
    <span class="kw">for</span> s <span class="kw">in</span> v { accum += s.height() }
    accum
}</code></pre></div>
</section><section id="trait-impls" class="slide level2">
<h1>Trait Impls</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Rect { w: <span class="dt">u32</span>, h: <span class="dt">u32</span> }
<span class="kw">struct</span> Circle { r: <span class="dt">u32</span> }

<span class="kw">impl</span> Dimensioned <span class="kw">for</span> Rect {
    <span class="kw">fn</span> height(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span> { <span class="kw">self</span>.h }
    <span class="kw">fn</span> width(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span> { <span class="kw">self</span>.w }
}

<span class="kw">impl</span> Dimensioned <span class="kw">for</span> Circle {
    <span class="kw">fn</span> height(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span> { <span class="kw">self</span>.r * <span class="dv">2</span> }
    <span class="kw">fn</span> width(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u32</span> { <span class="kw">self</span>.r * <span class="dv">2</span> }
}</code></pre></div>
</section><section id="traits-in-action" class="slide level2">
<h1>Traits in Action</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Rect {
    <span class="kw">fn</span> square(l: <span class="dt">u32</span>) -&gt; Rect { Rect { w: l, h: l } }
}
<span class="kw">impl</span> Circle {
    <span class="kw">fn</span> with_radius(r: <span class="dt">u32</span>) -&gt; Circle { Circle { r: r } }
}

<span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> trait_bounded_polymorphism() {
    <span class="kw">let</span> squares = [ Rect::square(<span class="dv">1</span>), Rect::square(<span class="dv">2</span>) ];
    <span class="kw">let</span> circles = [ Circle::with_radius(<span class="dv">1</span>), Circle::with_radius(<span class="dv">2</span>)];
    <span class="pp">assert_eq!</span>(stacked_height(&amp;squares), <span class="dv">3</span>);
    <span class="pp">assert_eq!</span>(stacked_height(&amp;circles), <span class="dv">6</span>);
}</code></pre></div>
</section><section id="generics-do-not-suffice" class="slide level2">
<h1>Generics do not suffice</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> parametric_fail() {
    <span class="kw">let</span> shapes = [Rect::square(<span class="dv">1</span>), Circle::with_radius(<span class="dv">2</span>)];
    <span class="pp">assert_eq!</span>(stacked_height(&amp;shapes), <span class="dv">5</span>);
}</code></pre></div>
<pre class="fragment"><code>error: mismatched types:
 expected `Rect`,
    found `Circle`
    let shapes = [Rect::square(1), Circle::with_radius(2)];
                                   ^~~~~~~~~~~~~~~~~~~~~~</code></pre>
</section><section id="uniformity-of-t-in-vect-is-why" class="slide level2">
<h1>Uniformity of <code>T</code> in <code>Vec&lt;T&gt;</code> is why</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="kw">struct</span> Rect { w: <span class="dt">u32</span>, h: <span class="dt">u32</span> }
<span class="kw">struct</span> Circle { r: <span class="dt">u32</span> }

<span class="kw">fn</span> parametric_fail() {
    <span class="kw">let</span> shapes = [Rect::square(<span class="dv">1</span>), Circle::with_radius(<span class="dv">2</span>)];
    <span class="co">//  ~~~~~~    ~~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~</span>
    <span class="co">//    |              |                    |</span>
    <span class="co">//    |       This is 8 bytes     This is 4-bytes</span>
    <span class="co">//    |</span>
    <span class="co">//  There&#39;s no uniform array</span>
    <span class="co">//  type to hold both in-line.</span>
}</code></pre></div>
</section><section id="this-is-a-job-for-..." class="slide level2">
<h1>This is a job for ...</h1>
<h3 id="object-oriented-programming" class="fragment">Object-Oriented Programming!</h3>
</section><section id="traits-as-objects-1" class="slide level2">
<h1>Traits as Objects 1</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> stacked_obj_refs(v: &amp;[&amp;Dimensioned]) -&gt; <span class="dt">u32</span> {
    <span class="kw">let</span> <span class="kw">mut</span> accum = <span class="dv">0</span>;
    <span class="kw">for</span> s <span class="kw">in</span> v { accum += s.height() }
    accum
}

<span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_objs_1() {
    <span class="kw">let</span> r = Rect::square(<span class="dv">1</span>);
    <span class="kw">let</span> c = Circle::with_radius(<span class="dv">2</span>);
    <span class="kw">let</span> shapes: [&amp;Dimensioned; <span class="dv">2</span>] = [&amp;r, &amp;c];
    <span class="pp">assert_eq!</span>(stacked_obj_refs(&amp;shapes), <span class="dv">5</span>);
}</code></pre></div>
</section><section id="traits-as-objects-2" class="slide level2">
<h1>Traits as Objects 2</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> stacked_obj_boxes(v: &amp;[<span class="dt">Box</span>&lt;Dimensioned&gt;]) -&gt; <span class="dt">u32</span> {
    <span class="kw">let</span> <span class="kw">mut</span> accum = <span class="dv">0</span>;
    <span class="kw">for</span> s <span class="kw">in</span> v { accum += s.height() }
    accum
}

<span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_objs_2() {
    <span class="kw">let</span> shapes: [<span class="dt">Box</span>&lt;Dimensioned&gt;; <span class="dv">2</span>] =
        [<span class="dt">Box</span>::new(Rect::square(<span class="dv">1</span>)), <span class="dt">Box</span>::new(Circle::with_radius(<span class="dv">2</span>))];
    <span class="pp">assert_eq!</span>(stacked_obj_boxes(&amp;shapes), <span class="dv">5</span>);
}</code></pre></div>
</section><section id="oop-is-nice-how-about-functional-programming" class="slide level2">
<h1>OOP is nice; how about Functional Programming?</h1>
</section><section id="closures-1" class="slide level2">
<h1>Closures 1</h1>
<ul>
<li><p>Can pass functions around as first class entities</p></li>
<li><p>Functions can <em>close</em> over externally defined state</p></li>
</ul>
<p>Reminder from Javascript:</p>
<p><code class="filename">closures.js</code></p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">add3</span>(x) <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span>

<span class="co">// take function as parameter:</span>
<span class="kw">function</span> <span class="at">do_twice</span>(f<span class="op">,</span> y) <span class="op">{</span> <span class="cf">return</span> <span class="at">f</span>(<span class="at">f</span>(y))<span class="op">;</span> <span class="op">}</span>

<span class="co">// return function that references outer parameter `z`</span>
<span class="kw">function</span> <span class="at">make_adder</span>(z) <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">function</span>(w) <span class="op">{</span> <span class="cf">return</span> w <span class="op">+</span> z<span class="op">;</span> <span class="op">};</span>
<span class="op">}</span>

<span class="kw">var</span> add4 <span class="op">=</span> <span class="at">make_adder</span>(<span class="dv">4</span>)<span class="op">;</span>
<span class="kw">var</span> ten <span class="op">=</span> <span class="at">do_twice</span>(add4<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></code></pre></div>
</section><section id="closures-2" class="slide level2">
<h1>Closures 2</h1>
<ul>
<li><p>In (classic) Javascript, closure syntax is:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> (args<span class="op">,</span> ...) <span class="op">{</span> body<span class="op">;</span> ... <span class="op">}</span></code></pre></div>
<p>where <code>body</code> can refer to things from outside.</p></li>
<li><p>In Rust, the analogous closure expression syntax is:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">|args, ...| { body; ... }</code></pre></div>
<p>with a few extra details:</p></li>
</ul>
<div class="fragment">
<ul>
<li><p>opt. <code class="sourceCode rust"><span class="kw">move</span></code> (forces capture-by-move)</p></li>
<li><p>opt. arg. and return types (inferred when omitted)</p></li>
</ul>
</div>
</section><section id="closures-3" class="slide level2">
<h1>Closures 3</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_closure() {
    <span class="kw">fn</span> add3(x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> { x + <span class="dv">3</span> } <span class="co">// &lt;- fn, *not* a closure</span>
    <span class="kw">fn</span> do_twice1&lt;F:<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>&gt;(f: F, x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> { f(f(x)) }
    <span class="co">//             ~~~~~~~~~~~~~~ closure type</span>
    <span class="kw">fn</span> do_twice2(f: &amp;<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>, x: <span class="dt">i32</span>) -&gt; <span class="dt">i32</span> { f(f(x)) }

    <span class="kw">fn</span> make_adder(y: <span class="dt">i32</span>) -&gt; <span class="dt">Box</span>&lt;<span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span>&gt; {
        <span class="dt">Box</span>::new(<span class="kw">move</span> |x| { x + y })
            <span class="co">//   ~~~~~~~~~~~~~~~~~~ closure expression</span>
    }

    <span class="kw">let</span> add4 = make_adder(<span class="dv">4</span>);
    <span class="kw">let</span> six = do_twice1(&amp;add3, <span class="dv">0</span>); <span class="kw">let</span> ten = do_twice1(&amp;*add4, <span class="dv">2</span>);
    <span class="pp">assert_eq!</span>((six, ten), (<span class="dv">6</span>, <span class="dv">10</span>));
    <span class="kw">let</span> six = do_twice2(&amp;add3, <span class="dv">0</span>); <span class="kw">let</span> ten = do_twice2(&amp;*add4, <span class="dv">2</span>);
    <span class="pp">assert_eq!</span>((six, ten), (<span class="dv">6</span>, <span class="dv">10</span>));
}</code></pre></div>
</section></section>
<section><section id="part-5-systems-development" class="titleslide slide level1"><h1>Part 5: Systems Development</h1></section><section id="concurrency" class="slide level2">
<h1>Concurrency</h1>
<p>Rust's killer feature:</p>
<h3 id="data-race-freedom">Data-race freedom</h3>
<p>built atop same foundation as memory safety</p>
</section><section id="heres-what-one-concurrency-api-looks-like" class="slide level2">
<h1>Here's what one concurrency API looks like</h1>
</section><section id="threadspawn" class="slide level2">
<h1><code>thread::spawn</code></h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> main() {
    <span class="kw">use</span> std::thread;
    <span class="kw">let</span> al = <span class="st">&quot;long lost pal&quot;</span>;
    thread::spawn(<span class="kw">move</span> || {

        <span class="pp">println!</span>(<span class="st">&quot;i can be your {}&quot;</span>, al);
    });

    <span class="pp">println!</span>(<span class="st">&quot;why am i soft in the middle&quot;</span>);
    <span class="co">// Note: might exit before spawned thread gets chance to print</span>
}</code></pre></div>
</section><section id="channels-for-message-passing" class="slide level2">
<h1>channels for message passing</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span> <span class="kw">fn</span> demo_channel() {
    <span class="kw">fn</span> fib(x: <span class="dt">i64</span>) -&gt; (<span class="dt">i64</span>, <span class="dt">i64</span>) { <span class="co">// returns `(x, fib(x))`</span>
        <span class="kw">if</span> x &lt;= <span class="dv">1</span> { (x,<span class="dv">1</span>) } <span class="kw">else</span> { (x, fib(x-<span class="dv">1</span>).<span class="dv">1</span> + fib(x-<span class="dv">2</span>).<span class="dv">1</span>) }
    }
    <span class="kw">use</span> std::thread;
    <span class="kw">use</span> std::sync::mpsc::channel;
    <span class="kw">let</span> (tx, rx) = channel(); <span class="co">// tx: &quot;transmit&quot;, rx: &quot;receive&quot;</span>
    <span class="kw">let</span> al = <span class="st">&quot;al&quot;</span>;
    thread::spawn(<span class="kw">move</span> || {
        tx.send(fib(<span class="dv">10</span>));
        <span class="pp">println!</span>(<span class="st">&quot;you can call me {}&quot;</span>, al);
    });
    <span class="kw">let</span> f_15 = fib(<span class="dv">15</span>).<span class="dv">1</span>;
    <span class="pp">println!</span>(<span class="st">&quot;why am i short of attention&quot;</span>);
    <span class="kw">let</span> f_10 = rx.recv().unwrap().<span class="dv">1</span>; <span class="co">// (this blocks to await data)</span>
    <span class="pp">assert_eq!</span>((f_10, f_15), (<span class="dv">89</span>, <span class="dv">987</span>));
}</code></pre></div>
<h4 id="channels-are-abstraction-data-race-free" class="fragment">channels are abstraction, data-race free</h4>
</section><section id="no-data-races-what-about-our-precious-mutation" class="slide level2">
<h1>No data races: What about our precious mutation?</h1>
</section><section id="no-data-races-1-direct-assign" class="slide level2" data-transition="fade-out">
<h1>No data races 1: &quot;direct&quot; assign</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span> <span class="kw">fn</span> demo_catch_direct() {
    <span class="kw">fn</span> fib(x: <span class="dt">i64</span>) -&gt; (<span class="dt">i64</span>, <span class="dt">i64</span>) { <span class="co">// returns `(x, fib(x))`</span>
        <span class="kw">if</span> x &lt;= <span class="dv">1</span> { (x,<span class="dv">1</span>) } <span class="kw">else</span> { (x, fib(x-<span class="dv">1</span>).<span class="dv">1</span> + fib(x-<span class="dv">2</span>).<span class="dv">1</span>) }
    }
    <span class="kw">use</span> std::thread;
    <span class="kw">let</span> al = <span class="st">&quot;al&quot;</span>;
    <span class="kw">let</span> <span class="kw">mut</span> f_10_recv = (<span class="dv">0</span>, <span class="dv">0</span>);

    thread::spawn(<span class="kw">move</span> || {
        f_10_recv = fib(<span class="dv">10</span>);
        <span class="pp">println!</span>(<span class="st">&quot;you can call me {}&quot;</span>, al);
    });
    <span class="kw">let</span> f_15 = fib(<span class="dv">15</span>).<span class="dv">1</span>;
    <span class="kw">while</span> f_10_recv.<span class="dv">0</span> == <span class="dv">0</span> { }  <span class="co">// &lt;-- many alarm bells</span>
    <span class="kw">let</span> f_10 = f_10_recv.<span class="dv">1</span>;
    <span class="pp">println!</span>(<span class="st">&quot;why am i short of attention&quot;</span>);
    <span class="pp">assert_eq!</span>((f_10, f_15), (<span class="dv">89</span>, <span class="dv">987</span>));
}</code></pre></div>
<h4 id="compiles-does-not-work-no-actual-communication-implicit-copying" class="fragment">compiles; does not work (no actual communication; implicit copying)</h4>
</section><section id="no-data-races-2-mut-ref" class="slide level2" data-transition="fade-in">
<h1>No data races 2: mut-ref</h1>
<div class="sourceCode"><pre class="sourceCode rust compile_error"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span> <span class="kw">fn</span> demo_catch_mutref() {
    <span class="kw">fn</span> fib(x: <span class="dt">i64</span>) -&gt; (<span class="dt">i64</span>, <span class="dt">i64</span>) { <span class="co">// returns `(x, fib(x))`</span>
        <span class="kw">if</span> x &lt;= <span class="dv">1</span> { (x,<span class="dv">1</span>) } <span class="kw">else</span> { (x, fib(x-<span class="dv">1</span>).<span class="dv">1</span> + fib(x-<span class="dv">2</span>).<span class="dv">1</span>) }
    }
    <span class="kw">use</span> std::thread;
    <span class="kw">let</span> al = <span class="st">&quot;al&quot;</span>;
    <span class="kw">let</span> <span class="kw">mut</span> f_10_recv = (<span class="dv">0</span>, <span class="dv">0</span>);
    <span class="kw">let</span> ptr_recv = &amp;<span class="kw">mut</span> f_10_recv; <span class="co">// &lt;-- Okay, say what we meant</span>
    thread::spawn(<span class="kw">move</span> || {
        *ptr_recv = fib(<span class="dv">10</span>);
        <span class="pp">println!</span>(<span class="st">&quot;you can call me {}&quot;</span>, al);
    });
    <span class="kw">let</span> f_15 = fib(<span class="dv">15</span>).<span class="dv">1</span>;
    <span class="kw">while</span> f_10_recv.<span class="dv">0</span> == <span class="dv">0</span> { }  <span class="co">// &lt;-- many alarm bells</span>
    <span class="kw">let</span> f_10 = f_10_recv.<span class="dv">1</span>;
    <span class="pp">println!</span>(<span class="st">&quot;why am i short of attention&quot;</span>);
    <span class="pp">assert_eq!</span>((f_10, f_15), (<span class="dv">89</span>, <span class="dv">987</span>));
}</code></pre></div>
<h4 id="does-not-compile-spawn-cant-share-ref-to-stack-local" class="fragment">does not compile: <code>spawn</code> can't share ref to stack-local</h4>
</section><section id="heres-a-totally-different-concurrency-api" class="slide level2">
<h1>Here's a totally different concurrency API</h1>
</section><section id="threadscoped" class="slide level2">
<h1><code>thread::scoped</code></h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> seq_max(partial_data: &amp;[<span class="dt">u8</span>]) -&gt; <span class="dt">u8</span> {
    *partial_data.iter().max().unwrap()
}

<span class="kw">fn</span> par_max(data: &amp;[<span class="dt">u8</span>]) -&gt; <span class="dt">u8</span> {
    <span class="kw">if</span> data.len() &lt;= <span class="dv">4</span> { <span class="kw">return</span> seq_max(data); }
    <span class="kw">let</span> len_4 = data.len() / <span class="dv">4</span>; <span class="co">// DATA = [A..B..C..D..]</span>
    <span class="kw">let</span> (q1, rest) = data.split_at(len_4); <span class="co">// (A.. \ B..C..D..)</span>
    <span class="kw">let</span> (q2, rest) = rest.split_at(len_4); <span class="co">//  (B.. \ C..D..)</span>
    <span class="kw">let</span> (q3, q4)   = rest.split_at(len_4); <span class="co">//   (C.. \ D..)</span>
    <span class="kw">let</span> t1 = ::std::thread::scoped(|| seq_max(q1)); <span class="co">// fork A..</span>
    <span class="kw">let</span> t2 = ::std::thread::scoped(|| seq_max(q2)); <span class="co">// fork B..</span>
    <span class="kw">let</span> t3 = ::std::thread::scoped(|| seq_max(q3)); <span class="co">// fork C..</span>
    <span class="kw">let</span> v4 = seq_max(q4); <span class="co">//                        compute D..</span>
    <span class="kw">let</span> (v1, v2, v3) = (t1.join(), t2.join(), t3.join()); <span class="co">// join!</span>
    <span class="kw">return</span> seq_max(&amp;[v1, v2, v3, v4]);
}</code></pre></div>
</section><section id="threadscoped-shows-a-new-trick" class="slide level2">
<h1><code>thread::scoped</code> shows a new trick</h1>
<ul>
<li><p><code>thread::spawn</code> disallowed passing refs to stack-local data</p></li>
<li><p>Allowing that is the whole point of <code>thread::scoped</code></p>
<ul>
<li>(caveat: <code>thread::scoped</code> API is unstable, and undergoing revision due to subtle soundness issue)</li>
</ul></li>
</ul>
</section><section id="benchmarking-par_max-1" class="slide level2">
<h1>Benchmarking <code>par_max</code> 1</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> test; <span class="kw">use</span> std::iter;
<span class="kw">const</span> LIL: <span class="dt">usize</span> = <span class="dv">20</span> * <span class="dv">1024</span>;
<span class="kw">const</span> BIG: <span class="dt">usize</span> = LIL * <span class="dv">1024</span>;

<span class="kw">fn</span> make_data(count: <span class="dt">usize</span>) -&gt; <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; {
    <span class="kw">let</span> <span class="kw">mut</span> data: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = iter::repeat(<span class="dv">10</span>).take(count).collect();
    data.push(<span class="dv">200</span>); data.push(<span class="dv">3</span>); <span class="kw">return</span> data;
}

<span class="at">#[</span>bench<span class="at">]</span> <span class="kw">fn</span> bench_big_seq(b: &amp;<span class="kw">mut</span> test::Bencher) {
    <span class="kw">let</span> data = make_data(BIG);
    b.iter(|| <span class="pp">assert_eq!</span>(seq_max(&amp;data), <span class="dv">200</span>));
}
<span class="at">#[</span>bench<span class="at">]</span> <span class="kw">fn</span> bench_big_par(b: &amp;<span class="kw">mut</span> test::Bencher) {
    <span class="kw">let</span> data = make_data(BIG);
    b.iter(|| <span class="pp">assert_eq!</span>(par_max(&amp;data), <span class="dv">200</span>));
}</code></pre></div>
<pre><code>bench_big_par ... bench:   3,763,711 ns/iter (+/- 1,140,321)
bench_big_seq ... bench:  21,633,799 ns/iter (+/- 2,522,262)</code></pre>
</section><section id="benchmarking-par_max-2" class="slide level2">
<h1>Benchmarking <code>par_max</code> 2</h1>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">const</span> LIL: <span class="dt">usize</span> = <span class="dv">20</span> * <span class="dv">1024</span>;
<span class="kw">const</span> BIG: <span class="dt">usize</span> = LIL * <span class="dv">1024</span>;</code></pre></div>
<pre><code>bench_big_par ... bench:   3,763,711 ns/iter (+/- 1,140,321)
bench_big_seq ... bench:  21,633,799 ns/iter (+/- 2,522,262)</code></pre>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>bench<span class="at">]</span> <span class="kw">fn</span> bench_lil_seq(b: &amp;<span class="kw">mut</span> test::Bencher) {
    <span class="kw">let</span> data = make_data(LIL);
    b.iter(|| <span class="pp">assert_eq!</span>(seq_max(&amp;data), <span class="dv">200</span>));
}
<span class="at">#[</span>bench<span class="at">]</span> <span class="kw">fn</span> bench_lil_par(b: &amp;<span class="kw">mut</span> test::Bencher) {
    <span class="kw">let</span> data = make_data(LIL);
    b.iter(|| <span class="pp">assert_eq!</span>(par_max(&amp;data), <span class="dv">200</span>));
}</code></pre></div>
<pre><code>bench_lil_par ... bench:      59,274 ns/iter (+/- 7,756)
bench_lil_seq ... bench:      15,432 ns/iter (+/- 1,961)</code></pre>
<p>(<code>fn par_max</code> could tune threshold for seq. path)</p>
</section><section id="what-was-that-about-preventing-data-races" class="slide level2">
<h1>What was that about preventing data races?</h1>
</section><section id="send-sync" class="slide level2">
<h1><code>Send</code>, <code>Sync</code></h1>
<ul>
<li><p>If <code>T: Send</code>, then passing (e.g. moving) a <code>T</code> to another thread is safe.</p></li>
<li><p>If <code>T: Sync</code>, then copying a <code>&amp;T</code> to another thread is safe.</p></li>
<li><p>(For Rust, &quot;safe&quot; includes &quot;no data races exposed.&quot;)</p></li>
</ul>
<!-- FIXME: elaborate, add e.g. counter-examples
Or maybe just drop this slide entirely.
-->
</section><section id="last-few-things" class="slide level2">
<h1>Last few things</h1>
</section><section id="io-in-rust" class="slide level2">
<h1>IO in Rust</h1>
<p>Many input/output (IO) routines can encounter errors</p>
<!--  (`panic!` from std lib not suitable for external errors) -->
<p>1.0 philosophy: <code>Result&lt;T, Error&gt;</code>; callers handle</p>
<pre><code>impl File { fn open&lt;P:AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;File&gt; }
impl&lt;B: BufRead&gt; Iterator for Lines&lt;B&gt; {       ~~~~~~~~~~
    type Item = io::Result&lt;String&gt;
}               ~~~~~~~~~~</code></pre>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_io() {
    <span class="kw">use</span> std::fs::File;
    <span class="kw">use</span> std::io::{<span class="kw">self</span>, BufReader, BufRead};
    <span class="kw">fn</span> do_io() -&gt; <span class="dt">Result</span>&lt;(), io::Error&gt; {
        <span class="kw">let</span> f = <span class="pp">try!</span>(File::open(<span class="st">&quot;/etc/ssh_config&quot;</span>));
        <span class="kw">let</span> buffered = BufReader::new(f);
        <span class="kw">for</span> l <span class="kw">in</span> buffered.lines().take(<span class="dv">10</span>) {
            <span class="pp">println!</span>(<span class="st">&quot;line: {}&quot;</span>, <span class="pp">try!</span>(l));
        }
        <span class="cn">Ok</span>(()) <span class="co">// (need to remember the result!)</span>
    }
    do_io().unwrap()
}</code></pre></div>
<!--
``` {.rust .heads_up .fragment }
try!(EXPR) rewrites to:
(match EXPR { Result::Ok(val) => val,
    Result::Err(err) => { return Result::Err(From::from(err)) } })
```
-->
<!--
``` {.rust .fragment}
macro_rules! try {
    ($expr:expr) => (match $expr {
        $crate::result::Result::Ok(val) => val,
        $crate::result::Result::Err(err) => {
            return $crate::result::Result::Err($crate::convert::From::from(err))
        }
    })
}
```
-->
<!--
FIXME: This slide could perhaps be at end of part 3.
(and presumably we could then move the Closures material here;
it just needs to precede discussion of thread APIs.)
-->
<!--

Anyway, the reason this slide was in here was that it "needs" to
precede our discussion of channels since those follow the I/O api
patterns of using `Result` and `try!`. Except I stopped using `try!`.
So I moved it, and maybe could drop it.

Pretty soon I'll draw up that dependency graph, using these slides as
a starting point.  :)

-->
</section><section id="unsafe-code" class="slide level2">
<h1><code class="sourceCode rust"><span class="kw">unsafe</span></code> code</h1>
<p>Bypass Rust's safety checking via <code class="sourceCode rust"><span class="kw">unsafe</span></code> (and take responsibility for safety)</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>should_panic<span class="at">]</span>
<span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_out_of_bounds_access() {
    <span class="kw">let</span> cap = {
        <span class="kw">let</span> v0 = <span class="dt">Vec</span>::from(<span class="st">&quot;Goodbye World!&quot;</span>);
        v0.capacity()
    }; <span class="co">// &lt;--- `v0` backing store is free&#39;d here</span>
    <span class="kw">let</span> <span class="kw">mut</span> new_v: <span class="dt">Vec</span>&lt;<span class="dt">u8</span>&gt; = <span class="dt">Vec</span>::with_capacity(cap); <span class="co">// &quot;uninitialized&quot;</span>
    <span class="kw">unsafe</span> { new_v.set_len(cap); }                    <span class="co">// UH OH</span>
    <span class="pp">println!</span>(<span class="st">&quot;v[0..4]: {:?} b&#39;Good&#39;: {:?}&quot;</span>, &amp;new_v[<span class="dv">0.</span>.<span class="dv">4</span>], b<span class="st">&quot;Good&quot;</span>);
    <span class="pp">panic!</span>(<span class="st">&quot;unsafe demo&quot;</span>);
}</code></pre></div>
<p>On my machine, prints:</p>
<pre><code>v[0..4]: [71, 111, 111, 100] b&#39;Good&#39;: [71, 111, 111, 100]</code></pre>
<h5 id="yay-we-can-still-have-security-bugs" class="fragment">(&quot;Yay,&quot; we can still have security bugs!)</h5>
</section><section id="native-pointers" class="slide level2">
<h1>native pointers</h1>
<p>Type classification, for any type <code>T</code></p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Safe References</span>
&amp;T
&amp;<span class="kw">mut</span> T</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Unsafe pointers</span>
*<span class="kw">mut</span> T
*<span class="kw">const</span> T</code></pre></div>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_unsafe_pointer() {
    <span class="kw">let</span> x = [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];
    <span class="kw">let</span> p = &amp;x[<span class="dv">0</span>] <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">i32</span>;
    <span class="kw">unsafe</span> { <span class="pp">println!</span>(<span class="st">&quot;p[0]: {} p[2]: {}&quot;</span>, *p, *p.offset(<span class="dv">2</span>)); }
}</code></pre></div>
<p>prints:</p>
<pre class="fragment" data-frament-index="1"><code>p[0]: 3 p[2]: 5</code></pre>
</section><section id="ffi" class="slide level2">
<h1>FFI</h1>
<!--
     void
     qsort(void *base, size_t nel, size_t width,
         int (*compar)(const void *, const void *));
-->
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> libc::<span class="dt">c_int</span> <span class="kw">as</span> <span class="dt">int</span>; <span class="kw">use</span> libc::<span class="dt">c_void</span> <span class="kw">as</span> void; <span class="kw">use</span> libc::<span class="dt">size_t</span>;
<span class="kw">use</span> std::mem::size_of;
<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> {
    <span class="kw">fn</span> qsort(base: *<span class="kw">mut</span> void, nel: <span class="dt">size_t</span>, width: <span class="dt">size_t</span>,
             compar: *<span class="kw">const</span> <span class="kw">extern</span> <span class="kw">fn</span> (*<span class="kw">const</span> void,
                                       *<span class="kw">const</span> void) -&gt; <span class="dt">int</span>);
}
<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="kw">fn</span> compar_i32(x: *<span class="kw">const</span> void, y: *<span class="kw">const</span> void) -&gt; <span class="dt">int</span> {
    <span class="kw">unsafe</span> { *(x <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">i32</span>) - *(y <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">i32</span>) }
}
<span class="at">#[</span>test<span class="at">]</span>
<span class="kw">fn</span> demo_ffi() {
    <span class="kw">let</span> <span class="kw">mut</span> data: [<span class="dt">i32</span>; <span class="dv">9</span>] = [<span class="dv">9</span>, <span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];
    <span class="kw">unsafe</span> { <span class="kw">let</span> ptr = &amp;<span class="kw">mut</span> data[<span class="dv">0</span>] <span class="kw">as</span> *<span class="kw">mut</span> <span class="dt">i32</span>;
        qsort(ptr <span class="kw">as</span> *<span class="kw">mut</span> void, <span class="dv">9</span>, <span class="dv">4</span>, compar_i32 <span class="kw">as</span> *<span class="kw">const</span> _);
    }
    <span class="pp">assert_eq!</span>(data, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>]);
}</code></pre></div>
<!--
TODO: potential exercise: Felix iteratively developed the qsort inputs based
on compiler errors. Maybe explore the space of small modifications to the
code above and see (1.) what errors it yields, and (2.) whether you can come
up with a simpler expression that still compiles and works.
-->
<!--
## Rust in Gecko (demonstration)
-->
</section></section>
<section><section id="conclusion" class="titleslide slide level1"><h1>Conclusion</h1></section><section id="rust" class="slide level2 left_align">
<h1>Rust</h1>
<div class="fragment">
<ul>
<li><p>Access to (many!) safe concurrency primitives</p></li>
<li><p>Access arbitrary native services</p></li>
</ul>
</div>
<div class="fragment">
<ul>
<li><p>Ownership and Borrowing are deep parts of language</p></li>
<li><p><code>rustc</code> catches bugs!</p></li>
</ul>
</div>
<div class="fragment">
<ul>
<li>HACK WITHOUT FEAR!</li>
</ul>
</div>
</section></section>
<section><section id="thanks-everyone-for-attending" class="titleslide slide level1"><h1>Thanks everyone for attending</h1></section><section id="lets-thank-the-helpers-from-the-research-team-as-well" class="slide level2">
<h1>Lets thank the helpers from the Research team as well</h1>
</section><section id="go-out-and-hack-some-rust" class="slide level2">
<h1>Go out and hack some Rust!</h1>
</section></section>
    </div>
  </div>


  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,         // Display controls in the bottom right corner
        progress: true,         // Display a presentation progress bar
        history: true,          // Push each slide change to the browser history
        center: true,                       // Vertical centering of slides
        maxScale: 1.5,                  // Bounds for smallest/largest possible content scale
        slideNumber: false,                // Display the page number of the current slide
        theme: 'simple', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
